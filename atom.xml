<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-13T07:00:54.414Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>复杂网络基础</title>
    <link href="http://example.com/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-13T08:50:34.000Z</published>
    <updated>2023-02-13T07:00:54.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="集聚系数"><a href="#集聚系数" class="headerlink" title="集聚系数"></a>集聚系数</h2><ol><li><strong>局部集聚系数</strong>: 节点集实际连边数/理论最大连边数</li><li><strong>全局集聚系数</strong>: 3x三角形个数/三元组个数<blockquote><p>如何计算三元组个数：$C_{d_i}^2$</p></blockquote></li></ol><h2 id="介数"><a href="#介数" class="headerlink" title="介数"></a>介数</h2><p>节点i的介数：所有最短路径中，经过节点i的数量<br>边ij的介数：所有最短路径中，经过边ij的数量</p><h2 id="核度"><a href="#核度" class="headerlink" title="核度"></a>核度</h2><p>若一个节点属于k核而不属于（k+1）核，则该节点核度为k</p><h1 id="随机网络"><a href="#随机网络" class="headerlink" title="随机网络"></a>随机网络</h1><h2 id="ER生成算法"><a href="#ER生成算法" class="headerlink" title="ER生成算法"></a>ER生成算法</h2><p>G(N,L) vs. G(N,p)</p><pre><code class="python">def GNL(N,L)    G=nx.Graph()    nlist=list(G.add_nodes_from(range(N)))    edge_count=0    while edge_count&lt;L:        u=random.choice(nlist)        v=random.choice(nlist)        if u==v or G.has_edge(u,v):            continue        else:            G.add_edge(u,v)            edge_count+=1    return G</code></pre><pre><code class="python">def GNP(N,p)    G=nx.Graph()    G.add_nodes_from(range(N))    edges=itertools.combinations(range(N),2)    for e in edges:        if random.random()&lt;p:            G.add_edge(*e)    return G</code></pre><h2 id="ER随机网络的性质"><a href="#ER随机网络的性质" class="headerlink" title="ER随机网络的性质"></a>ER随机网络的性质</h2><ol><li>$平均度=p(N-1)$</li><li>度分布为二项分布，在较大网络中近似为泊松分布<br><img src="/Pasted%20image%2020230127211443.png"></li><li>当N趋于无穷，度分布为泊松分布，平均距离小，集聚系数小</li><li>巨连通分支规模和p的关系<blockquote><p>横坐标为$pN$，纵坐标为$巨连通分支节点数/N$</p></blockquote></li></ol><p><img src="/Pasted%20image%2020230127212153.png"></p><p><img src="/Pasted%20image%2020230127212953.png"></p><h1 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h1><p><strong>小</strong>的定义：平均距离正比于$lnN$</p><h2 id="WS模型"><a href="#WS模型" class="headerlink" title="WS模型"></a>WS模型</h2><p>在k近邻规则网络中对边进行重连</p><blockquote><p>性质：随机重连前，集聚系数较高，平均距离较大；随机重连后，平均距离变小，集聚系数的降低需要更高的重连概率，越来越趋近于随机网络<br><img src="/Pasted%20image%2020230128144525.png"></p></blockquote><h2 id="NW模型"><a href="#NW模型" class="headerlink" title="NW模型"></a>NW模型</h2><p>在k近邻规则网络中以p的概率加边</p><h1 id="无标度（幂律）网络"><a href="#无标度（幂律）网络" class="headerlink" title="无标度（幂律）网络"></a>无标度（幂律）网络</h1><h2 id="离散形式"><a href="#离散形式" class="headerlink" title="离散形式"></a>离散形式</h2><p>$$<br>p_k=Ck^{-\gamma}<br>$$<br>$$<br>\sum_{k=1}^\infty p_k=1<br>$$</p><h2 id="和随机网络的对比"><a href="#和随机网络的对比" class="headerlink" title="和随机网络的对比"></a>和随机网络的对比</h2><p>两头多，中间少</p><blockquote><p>紫色为无标度网络，绿色为随机网络（泊松分布）。度分布-双对数坐标轴。<br><img src="/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230128194302960.png"></p></blockquote><h2 id="最大度期望"><a href="#最大度期望" class="headerlink" title="最大度期望"></a>最大度期望</h2><p>$$<br>k_{max}=k_{min}N^{\frac{1}{\gamma-1}}<br>$$</p><ol><li>总节点数越大，最大度和最小度的期望差距越大</li><li>$\gamma$ 越大，最大度和最小度的期望差距越小</li></ol><h2 id="平均距离"><a href="#平均距离" class="headerlink" title="平均距离"></a>平均距离</h2><p><img src="/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230128203233246.png"></p><h2 id="集聚系数-1"><a href="#集聚系数-1" class="headerlink" title="集聚系数"></a>集聚系数</h2><p>$$<br>\langle C \rangle \sim\frac{(lnN)^2}{N}<br>$$</p><h2 id="度保持的随机化"><a href="#度保持的随机化" class="headerlink" title="度保持的随机化"></a>度保持的随机化</h2><p>nx.double_edge_swap</p><pre><code>u--v            u  v       becomes  |  |x--y            x  y</code></pre><h1 id="BA无标度网络"><a href="#BA无标度网络" class="headerlink" title="BA无标度网络"></a>BA无标度网络</h1><ol><li>网络是逐步生长的</li><li>每个时间步增加m个节点，优先选择度高的节点（偏好连接）<br><img src="/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230128233914746.png"></li></ol><h2 id="非线性偏好连接"><a href="#非线性偏好连接" class="headerlink" title="非线性偏好连接"></a>非线性偏好连接</h2><p><img src="/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230128235913105.png"></p><h1 id="网络鲁棒性"><a href="#网络鲁棒性" class="headerlink" title="网络鲁棒性"></a>网络鲁棒性</h1><h2 id="集聚影响力（Collective-Influence）"><a href="#集聚影响力（Collective-Influence）" class="headerlink" title="集聚影响力（Collective Influence）"></a>集聚影响力（Collective Influence）</h2><p><img src="/2023/02/13/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/image-20230129205022475.png"></p><blockquote><p>可以用偏导符号表示k阶邻居 #H2GCN</p></blockquote><h1 id="社团检测"><a href="#社团检测" class="headerlink" title="社团检测"></a>社团检测</h1><p><strong>强社区</strong>：社区内部节点的度都大于外部节点的度<br><strong>弱社区</strong>：社区内部节点的度之和大于外部节点的度之和</p><h2 id="层次聚类算法"><a href="#层次聚类算法" class="headerlink" title="层次聚类算法"></a>层次聚类算法</h2><h3 id="劳沃斯算法（凝聚算法）"><a href="#劳沃斯算法（凝聚算法）" class="headerlink" title="劳沃斯算法（凝聚算法）"></a>劳沃斯算法（凝聚算法）</h3><ol><li>将每个节点视为一个社区</li><li>计算社区两两相似度（平均簇相似度）</li><li>合并相似度最高的两个社区（如果有至少一条连边），绘制树状图</li><li>重复步骤2和3，直到所有节点被并入一个社区</li></ol><h3 id="格文-纽曼算法（分裂算法）"><a href="#格文-纽曼算法（分裂算法）" class="headerlink" title="格文-纽曼算法（分裂算法）"></a>格文-纽曼算法（分裂算法）</h3><ol><li>计算每条边的介数，删除最高的若干条，直到有子图分离</li><li>将分离的若干个子图作为新的叶子节点，直到这些子图只有一个节点</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图论&quot;&gt;&lt;a href=&quot;#图论&quot; class=&quot;headerlink&quot; title=&quot;图论&quot;&gt;&lt;/a&gt;图论&lt;/h1&gt;&lt;h2 id=&quot;集聚系数&quot;&gt;&lt;a href=&quot;#集聚系数&quot; class=&quot;headerlink&quot; title=&quot;集聚系数&quot;&gt;&lt;/a&gt;集聚系数&lt;/h</summary>
      
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="math" scheme="http://example.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>头条大数据推荐项目</title>
    <link href="http://example.com/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-02-13T05:44:39.000Z</published>
    <updated>2023-02-13T06:56:48.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230211193156286.png"></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="启动-hadoop、hive-连接-mysql"><a href="#启动-hadoop、hive-连接-mysql" class="headerlink" title="启动 hadoop、hive(连接 mysql)"></a>启动 hadoop、hive(连接 mysql)</h2><pre><code class="shell">#~/hadoop_code/start_hive.shstart-all.shservice docker startdocker start mysqlhive --service metastore &amp;</code></pre><pre><code class="shell">#查看mysqldocker exec -it mysql bashmysql -uroot -p#密码: passwordctrl+P+Q 退出</code></pre><h2 id="启动-hbase、spark、thriftserver"><a href="#启动-hbase、spark、thriftserver" class="headerlink" title="启动 hbase、spark、thriftserver"></a>启动 hbase、spark、thriftserver</h2><pre><code class="shell">cd ~/bigdatastart-hbase.sh./spark/sbin/start-all.shhbase thrift start</code></pre><h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><pre><code class="shell">jps10948 ThriftServer3816 ResourceManager3145 DataNode6571 HMaster4813 RunJar7667 Master13557 Jps6998 HRegionServer9691 Worker9948 RunJar3645 SecondaryNameNode2751 NameNode4223 NodeManager6463 HQuorumPeer</code></pre><h1 id="离线计算更新物品画像"><a href="#离线计算更新物品画像" class="headerlink" title="离线计算更新物品画像"></a>离线计算更新物品画像</h1><h2 id="用-Sqoop-迁移和同步数据库"><a href="#用-Sqoop-迁移和同步数据库" class="headerlink" title="用 Sqoop 迁移和同步数据库"></a>用 Sqoop 迁移和同步数据库</h2><p>业务数据通常存放在 mysql 数据库中，我们需要把它定期同步到 hadoop 的 hive 数据仓库中。</p><pre><code class="sql">create database if not exists toutiao comment "user,news information of 136 mysql" location '/user/hive/warehouse/toutiao.db/';</code></pre><pre><code class="shell">sqoop list-databases --connect jdbc:mysql://192.168.19.137:3306/ --username root -P</code></pre><p>密码：<strong>password</strong><br>会显示连接到的数据库:</p><pre><code>information_schemahivemysqlperformance_schemasystoutiao</code></pre><p>写增量导入的 Sqoop 脚本</p><pre><code class="shell">#/root/toutiao_project/scripts/import_incremental.shtime=`date +"%Y-%m-%d" -d "-1day"`declare -A checkcheck=([user_profile]=update_time [user_basic]=last_login [news_channel]=update_time)declare -A mergemerge=([user_profile]=user_id [user_basic]=user_id [news_channel]=channel_id)for k in ${!check[@]}do    sqoop import \        --connect jdbc:mysql://192.168.19.137/toutiao \        --username root \        --password password \        --table $k \        --m 4 \        --target-dir /user/hive/warehouse/toutiao.db/$k \        --incremental lastmodified \        --check-column ${check[$k]} \        --merge-key ${merge[$k]} \        --last-value ${time}done</code></pre><p>写 crontab-shell 脚本让 Sqoop 定时运行</p><pre><code class="shell">crontab -e#每30分钟运行一次*/30 * * * * /root/toutiao_project/scripts/import_incremental.shservice crond start</code></pre><blockquote><p>这里 MySQL 里面没有创建好，实际会报错，不管。</p></blockquote><h2 id="用户行为埋点收集"><a href="#用户行为埋点收集" class="headerlink" title="用户行为埋点收集"></a>用户行为埋点收集</h2><h3 id="埋点设置"><a href="#埋点设置" class="headerlink" title="埋点设置"></a>埋点设置</h3><pre><code class="json"># 曝光的参数，{"actionTime":"2019-04-10 18:15:35","readTime":"","channelId":0,"param":{"action": "exposure", "userId": "2", "articleId": "[18577, 14299]", "algorithmCombine": "C2"}}# 对文章发生行为的参数{"actionTime":"2019-04-10 18:12:11","readTime":"2886","channelId":18,"param":{"action": "read", "userId": "2", "articleId": "18005", "algorithmCombine": "C2"}}{"actionTime":"2019-04-10 18:15:32","readTime":"","channelId":18,"param":{"action": "click", "userId": "2", "articleId": "18005", "algorithmCombine": "C2"}}{"actionTime":"2019-04-10 18:15:34","readTime":"1053","channelId":18,"param":{"action": "read", "userId": "2", "articleId": "18005", "algorithmCombine": "C2"}}...</code></pre><h3 id="用-flume-收集到-hive-中"><a href="#用-flume-收集到-hive-中" class="headerlink" title="用 flume 收集到 hive 中"></a>用 flume 收集到 hive 中</h3><p>创建 flume 配置文件</p><pre><code class="shell">#/root/bigdata/flume/collect_click.confa1.sources = s1a1.sinks = k1a1.channels = c1# 实时查看日志文件尾a1.sources.s1.channels= c1a1.sources.s1.type = execa1.sources.s1.command = tail -F /root/logs/userClick.log# 设置两个拦截器 1.格式过滤 2.附加时间戳a1.sources.s1.interceptors=i1 i2a1.sources.s1.interceptors.i1.type=regex_filtera1.sources.s1.interceptors.i1.regex=\\{.*\\}a1.sources.r1.interceptors.i1.excludeEvents = falsea1.sources.s1.interceptors.i2.type=timestamp# 指定缓冲区和batchdataa1.channels.c1.type=memorya1.channels.c1.capacity=30000a1.channels.c1.transactionCapacity=1000# 连接hdfsa1.sinks.k1.type=hdfsa1.sinks.k1.channel=c1a1.sinks.k1.hdfs.path=hdfs://192.168.19.137:9000/user/hive/warehouse/profile.db/user_action/%Y-%m-%da1.sinks.k1.hdfs.useLocalTimeStamp = truea1.sinks.k1.hdfs.fileType=DataStreama1.sinks.k1.hdfs.writeFormat=Texta1.sinks.k1.hdfs.rollInterval=0a1.sinks.k1.hdfs.rollSize=10240a1.sinks.k1.hdfs.rollCount=0a1.sinks.k1.hdfs.idleTimeout=60</code></pre><p>hive 中创建数据库和表</p><pre><code class="sql">create database if not exists profile comment "user action" location '/user/hive/warehouse/profile.db/';create table user_action(actionTime STRING comment "user actions time",readTime STRING comment "user reading time",channelId INT comment "article channel id",param map comment "action parameter")COMMENT "user primitive action"PARTITIONED BY(dt STRING)ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe'LOCATION '/user/hive/warehouse/profile.db/user_action';</code></pre><p><code>ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe'</code>:添加 json 格式匹配功能</p><p>flume 会自动生成目录，在 hive 内部表上直接同步。但是如果想要通过 spark sql 获取内容，每天还是要主动关联：</p><pre><code class="sql">alter table user_action add partition (dt='2023-02-11') location "/user/hive/warehouse/profile.db/user_action/2023-02-11/"</code></pre><h3 id="使用-supervisor-管理-flume-进程"><a href="#使用-supervisor-管理-flume-进程" class="headerlink" title="使用 supervisor 管理 flume 进程"></a>使用 supervisor 管理 flume 进程</h3><p>flume 及其依赖写入脚本/root/toutiao_project/scripts/collect-click.sh</p><pre><code class="shell">#!/usr/bin/env bashexport JAVA_HOME=/root/bigdata/jdkexport HADOOP_HOME=/root/bigdata/hadoopexport PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin/root/bigdata/flume/bin/flume-ng agent -c /root/bigdata/flume/conf -f /root/bigdata/flume/conf/collect_click.conf -Dflume.root.logger=INFO,console -name a1</code></pre><p>在/etc/supervisor 的 reco.conf 添加</p><pre><code class="shell">[program:collect-click]command=/bin/bash /root/toutiao_project/scripts/collect_click.shuser=rootautorestart=trueredirect_stderr=truestdout_logfile=/root/logs/collect.logloglevel=infostopsignal=KILLstopasgroup=truekillasgroup=true</code></pre><p>最后用 supervisord 启动收集</p><pre><code class="shell">pip install supervisorsupervisord -c /etc/supervisord.confsupervisorctl status</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="shell">echo {\"actionTime\":\"2023-02-11 21:04:39\",\"readTime\":\"\",\"channelId\":18,\"param\":{\"action\": \"click\", \"userId\": \"2\", \"articleId\": \"14299\", \"algorithmCombine\": \"C2\"}} &gt;&gt; userClick.log</code></pre><p>在 <a href="http://192.168.19.137:50070/explorer.html#/user/hive/warehouse/profile.db/user_action/">前端页面</a> 和 hive 中应当看到结果。</p><h2 id="离线文章画像计算"><a href="#离线文章画像计算" class="headerlink" title="离线文章画像计算"></a>离线文章画像计算</h2><h3 id="原始文章数据合并"><a href="#原始文章数据合并" class="headerlink" title="原始文章数据合并"></a>原始文章数据合并</h3><ol><li>创建 spark 基类</li><li>启动 jupyter</li></ol><pre><code class="shell">source activate py365jupyter notebook --allow-root --ip=192.168.19.137# 密码：123</code></pre><ol start="3"><li>运行 full_call/merge_data</li></ol><h3 id="历史文章-tfidf-计算"><a href="#历史文章-tfidf-计算" class="headerlink" title="历史文章 tfidf 计算"></a>历史文章 tfidf 计算</h3><ol><li>jieba 分词，去除停用词，保留名词、英文和自定义词库中的词</li><li>使用 spark ML 中 CountVectorizer 包进行词频统计，得到词袋模型/字典<br><img src="/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230211214707213.png"></li><li>使用 spark ML 中 IDF 包进一步计算每个单词的权重</li><li>根据索引和权重排序得到可以每篇文章权重最高的 20 个词</li></ol><h3 id="历史文章-textrank-计算"><a href="#历史文章-textrank-计算" class="headerlink" title="历史文章 textrank 计算"></a>历史文章 textrank 计算</h3><pre><code class="python">def textrank(partition):    import os    import jieba    import jieba.analyse    import jieba.posseg as pseg    import codecs    abspath = "/root/words"    # 结巴加载用户词典    userDict_path = os.path.join(abspath, "ITKeywords.txt")    jieba.load_userdict(userDict_path)    # 停用词文本    stopwords_path = os.path.join(abspath, "stopwords.txt")    def get_stopwords_list():        """返回stopwords列表"""        stopwords_list = [i.strip()                          for i in codecs.open(stopwords_path).readlines()]        return stopwords_list    # 所有的停用词列表    stopwords_list = get_stopwords_list()    class TextRank(jieba.analyse.TextRank):        def __init__(self, window=20, word_min_len=2):            super(TextRank, self).__init__()            self.span = window  # 窗口大小            self.word_min_len = word_min_len  # 单词的最小长度            # 要保留的词性，根据jieba github ，具体参见https://github.com/baidu/lac            self.pos_filt = frozenset(                ('n', 'x', 'eng', 'f', 's', 't', 'nr', 'ns', 'nt', "nw", "nz", "PER", "LOC", "ORG"))        def pairfilter(self, wp):            """过滤条件，返回True或者False"""            if wp.flag == "eng":                if len(wp.word) &lt;= 2:                    return False            if wp.flag in self.pos_filt and len(wp.word.strip()) &gt;= self.word_min_len \                    and wp.word.lower() not in stopwords_list:                return True    # TextRank过滤窗口大小为5，单词最小为2    textrank_model = TextRank(window=5, word_min_len=2)    allowPOS = ('n', "x", 'eng', 'nr', 'ns', 'nt', "nw", "nz", "c")</code></pre><p>同样可以给出 20 个关键词。但是最终结果由 Textank * IDF 再取前 20 给出<br><img src="/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230211220415129.png"></p><h3 id="训练词向量模型-word2vec-和增量文章编码"><a href="#训练词向量模型-word2vec-和增量文章编码" class="headerlink" title="训练词向量模型 word2vec 和增量文章编码"></a>训练词向量模型 word2vec 和增量文章编码</h3><pre><code class="python">from pyspark.ml.feature import Word2Vec# minCount忽略总频率低于此频率的所有单词w2v = Word2Vec(vectorSize=100, inputCol='words', outputCol='model', minCount=3)w2v_model = w2v.fit(words_df)w2v_model.write().overwrite().save("hdfs://hadoop-master:9000/headlines/models/test.word2vec")from pyspark.ml.feature import Word2VecModelword_vec = Word2VecModel.load("hdfs://hadoop-master:9000/headlines/models/test.word2vec")vectors = word_vec.getVectors()</code></pre><p>编码后和每个单词权重相乘，最终得到每篇文章的特征向量（文章画像）</p><h3 id="用-Apscheduler-定时更新文章画像"><a href="#用-Apscheduler-定时更新文章画像" class="headerlink" title="用 Apscheduler 定时更新文章画像"></a>用 Apscheduler 定时更新文章画像</h3><ol><li>增量更新文章编码，包括 hive 里的 article_profile<blockquote><p>新词可以用平均值填充</p></blockquote></li><li>定期重新计算 tfidf、textrank 和 word2vec 模型</li><li>Apsheduler 是 crontab 升级版</li></ol><pre><code class="python">import sysimport osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, os.path.join(BASE_DIR))sys.path.insert(0, os.path.join(BASE_DIR, 'reco_sys'))from apscheduler.schedulers.blocking import BlockingSchedulerfrom apscheduler.executors.pool import ProcessPoolExecutorfrom scheduler.update import update_article_profile# 创建scheduler，多进程执行executors = {    'default': ProcessPoolExecutor(3)}scheduler = BlockingScheduler(executors=executors)# 添加定时更新任务更新文章画像,每隔一小时更新scheduler.add_job(update_article_profile, trigger='interval', hours=1)scheduler.start()</code></pre><h1 id="离线用户召回集与排序计算"><a href="#离线用户召回集与排序计算" class="headerlink" title="离线用户召回集与排序计算"></a>离线用户召回集与排序计算</h1><h2 id="用户画像存储与获取"><a href="#用户画像存储与获取" class="headerlink" title="用户画像存储与获取"></a>用户画像存储与获取</h2><p>用户画像需要快速迭代，方便读取，选择存储在 hbase 中。这里我们从 hbase 关联到 hive。</p><pre><code class="sql">create external table user_profile_hbase(user_id STRING comment "userID",information map&lt;string, DOUBLE&gt; comment "user basic information",article_partial map&lt;string, DOUBLE&gt; comment "article partial",env map&lt;string, INT&gt; comment "user env")COMMENT "user profile table"STORED BY 'org.apache.hadoop.hive.hbase.HBaseStorageHandler'WITH SERDEPROPERTIES ("hbase.columns.mapping" = ":key,basic:,partial:,env:")TBLPROPERTIES ("hbase.table.name" = "user_profile");</code></pre><p>读取 user_article_basic 表，<strong>合并行为表</strong>与<strong>文章画像中的主题词</strong></p><pre><code class="python"># 获取基本用户行为信息，然后进行文章画像的主题词合并uup.spark.sql("use profile")# 取出日志中的channel_iduser_article_ = uup.spark.sql("select * from user_article_basic").drop('channel_id')uup.spark.sql('use article')article_label = uup.spark.sql("select article_id, channel_id, topics from article_profile")# 合并使用文章中正确的channel_idclick_article_res = user_article_.join(article_label, how='left', on=['article_id'])</code></pre><h3 id="用户权重计算公式"><a href="#用户权重计算公式" class="headerlink" title="用户权重计算公式"></a>用户权重计算公式</h3><p><strong>用户标签权重 =( 行为类型权重之和) × 时间衰减</strong></p><table><thead><tr><th>行为</th><th>分值</th></tr></thead><tbody><tr><td>阅读时间(&lt;1000)</td><td>1</td></tr><tr><td>阅读时间(&gt;=1000)</td><td>2</td></tr><tr><td>收藏</td><td>2</td></tr><tr><td>分享</td><td>3</td></tr><tr><td>点击</td><td>5</td></tr><tr><td><strong>时间衰减</strong>=1/(log(t)+1) ,t 为时间发生时间距离当前时间的大小</td><td></td></tr></tbody></table><p>使用 happybase 关联文章表，统计每个词的标签权重，得到用户的关键词喜好 top10</p><pre><code class="python">import happybase#  用于读取hbase缓存结果配置pool = happybase.ConnectionPool(size=10, host='192.168.19.137', port=9090)with pool.connection() as conn:    table = conn.table('user_profile')    # 获取每个键 对应的所有列的结果    data = table.row(b'user:2', columns=[b'partial'])    conn.close()</code></pre><p>完善代码后，添加到 Apscheduler 中</p><pre><code class="python">scheduler.add_job(update_user_profile, trigger='interval', hours=2)</code></pre><h2 id="召回排序"><a href="#召回排序" class="headerlink" title="召回排序"></a>召回排序</h2><ul><li>用户冷启动（前期点击行为较少情况）<ul><li>非个性化推荐<ul><li><strong>热门召回</strong>：自定义热门规则，根据当前时间段热点定期更新维护<em>热点文章库</em></li><li><strong>新文章召回</strong>：为了提高新文章的曝光率，建立<em>新文章库</em>，进行推荐</li></ul></li><li>个性化推荐：<ul><li><strong>基于内容的协同过滤在线召回</strong>：基于用户实时兴趣画像相似的召回结果用于首页的个性化推荐</li></ul></li></ul></li><li>后期离线部分（用户点击行为较多，用户画像完善）<ul><li>建立用户长期兴趣画像（详细）：包括用户各个维度的兴趣特征</li><li>训练排序模型<ul><li><strong>LR 模型、FTRL、Wide&amp;Deep</strong></li></ul></li><li>离线部分的召回：<ul><li><strong>基于模型协同过滤推荐离线召回</strong>：ALS</li><li><strong>基于内容的离线召回</strong>：或者称基于用户画像的召回</li></ul></li></ul></li></ul><h3 id="基于-ALS-模型的召回"><a href="#基于-ALS-模型的召回" class="headerlink" title="基于 ALS 模型的召回"></a>基于 ALS 模型的召回</h3><pre><code class="python">from pyspark.ml.recommendation import ALS# 模型训练和推荐默认每个用户固定文章个数als = ALS(userCol='als_user_id', itemCol='als_article_id', ratingCol='clicked', checkpointInterval=1)model = als.fit(als_user_article_click)recall_res = model.recommendForAllUsers(100)</code></pre><p>召回结果存储</p><pre><code class="python">def save_offline_recall_hbase(partition):    """离线模型召回结果存储    """    import happybase    pool = happybase.ConnectionPool(size=10, host='hadoop-master', port=9090)    for row in partition:        with pool.connection() as conn:            # 获取历史看过的该频道文章            history_table = conn.table('history_recall')            # 多个版本            data = history_table.cells('reco:his:{}'.format(row.user_id).encode(),                                       'channel:{}'.format(row.channel_id).encode())            history = []            if len(data) &gt;= 2:                for l in data[:-1]:                    history.extend(eval(l))            else:                history = []            # 过滤reco_article与history            reco_res = list(set(row.article_list) - set(history))            if reco_res:                table = conn.table('cb_recall')                # 默认放在推荐频道                table.put('recall:user:{}'.format(row.user_id).encode(),                          {'als:{}'.format(row.channel_id).encode(): str(reco_res).encode()})                conn.close()                # 放入历史推荐过文章                history_table.put("reco:his:{}".format(row.user_id).encode(),                                  {'channel:{}'.format(row.channel_id): str(reco_res).encode()})            conn.close()als_recall.foreachPartition(save_offline_recall_hbase)</code></pre><h3 id="基于内容的召回"><a href="#基于内容的召回" class="headerlink" title="基于内容的召回"></a>基于内容的召回</h3><p>即根据 LHS 等算法，快速得到用户当前点击文章的相似文章集，进行推荐。</p><pre><code class="python"># 循环partitionfor row in partition:    # 获取相似文章结果表    similar_article = similar_table.row(str(row.article_id).encode(),                                        columns=[b'similar'])    # 相似文章相似度排序过滤，召回不需要太大的数据， 百个，千    _srt = sorted(similar_article.items(), key=lambda item: item[1], reverse=True)    if _srt:        # 每次行为推荐若干篇文章        reco_article = [int(i[0].split(b':')[1]) for i in _srt][:10]</code></pre><blockquote><p>基于内容和基于模型的结果存入同一张 hbase 表</p></blockquote><pre><code class="sql">create external table cb_recall_hbase(user_id STRING comment "userID",als map&lt;string, ARRAY&lt;BIGINT&gt;&gt; comment "als recall",content map&lt;string, ARRAY&lt;BIGINT&gt;&gt; comment "content recall",online map&lt;string, ARRAY&lt;BIGINT&gt;&gt; comment "online recall")COMMENT "user recall table"STORED BY 'org.apache.hadoop.hive.hbase.HBaseStorageHandler'WITH SERDEPROPERTIES ("hbase.columns.mapping" = ":key,als:,content:,online:")TBLPROPERTIES ("hbase.table.name" = "cb_recall");</code></pre><h3 id="离线排序模型-CTR"><a href="#离线排序模型-CTR" class="headerlink" title="离线排序模型 CTR"></a>离线排序模型 CTR</h3><p>CTR（Click-Through Rate）预估：给定一个 Item，预测该 Item 会被点击的概率<br>最基础的模型目前都是基于 LR 的点击率预估策略，目前在工业使用模型做预估的有这么几种类型</p><ul><li>宽模型 + 特征⼯程<ul><li>LR/MLR + 非 ID 类特征(⼈⼯离散/GBDT/FM)</li><li>spark 中可以直接使用</li></ul></li><li>宽模型 + 深模型<ul><li>wide&amp;deep,DeepFM</li><li>使用 TensorFlow 进行训练</li></ul></li><li>深模型：<ul><li>DNN + 特征 embedding</li><li>使用 TensorFlow 进行训练</li></ul></li></ul><p>特征包含：用户画像关键词 10+文章画像关键词 10+channel_id(25, onehot)+文章主题词向量(concat, 100)</p><pre><code class="python">cols = ['article_id', 'user_id', 'channel_id', 'articlevector', 'weights', 'article_weights', 'clicked']train_version_two = VectorAssembler().setInputCols(cols[2:6]).setOutputCol("features").transform(train)</code></pre><p><img src="/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230212102837399.png"><br>训练线性回归模型，可以服务于在线召回</p><pre><code class="python">lr = LogisticRegression()model = lr.setLabelCol("clicked").setFeaturesCol("features").fit(train_version_two)model.save("hdfs://hadoop-master:9000/headlines/models/lr.obj")</code></pre><p>定期重新训练</p><h1 id="实时计算业务"><a href="#实时计算业务" class="headerlink" title="实时计算业务"></a>实时计算业务</h1><p>实时（在线）计算：</p><ul><li>解决用户冷启动问题</li><li>实时计算能够根据用户的点击实时反馈，快速跟踪用户的喜好</li></ul><p>日志数据我们已经收集到 hadoop 中，但是做实时分析的时候，我们需要将每个时刻用户产生的点击行为收集到 KAFKA 当中，等待 spark streaming 程序去消费。</p><h2 id="Kafka-简介"><a href="#Kafka-简介" class="headerlink" title="Kafka 简介"></a>Kafka 简介</h2><p><strong>Kafka</strong>是由<a href="https://zh.wikipedia.org/wiki/Apache%E8%BD%AF%E4%BB%B6%E5%9F%BA%E9%87%91%E4%BC%9A" title="Apache软件基金会">Apache 软件基金会</a>开发的一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90" title="开源">开源</a><a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%A4%84%E7%90%86" title="流处理">流处理</a>平台，由<a href="https://zh.wikipedia.org/wiki/Scala" title="Scala">Scala</a>和<a href="https://zh.wikipedia.org/wiki/Java" title="Java">Java</a>编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。</p><h2 id="flume-收集日志到-kafka"><a href="#flume-收集日志到-kafka" class="headerlink" title="flume 收集日志到 kafka"></a>flume 收集日志到 kafka</h2><p>开启 zookeeper,需要在一直在服务器端实时运行，以守护进程运行</p><pre><code class="shell">/root/bigdata/kafka/bin/zookeeper-server-start.sh -daemon /root/bigdata/kafka/config/zookeeper.properties</code></pre><p>以及 kafka</p><pre><code>/root/bigdata/kafka/bin/kafka-server-start.sh /root/bigdata/kafka/config/server.properties</code></pre><p>测试</p><pre><code class="shell"> #开启消息生产者/root/bigdata/kafka/bin/kafka-console-producer.sh --broker-list 192.168.19.137:9092 --sync --topic click-trace #开启消费者/root/bigdata/kafka/bin/kafka-console-consumer.sh --bootstrap-server 192.168.19.137:9092 --topic  click-trace#在生产者窗口输入任意内容测试</code></pre><p>修改原来收集日志的文件，添加 flume 收集日志行为到 kafka 的 source, channel, sink</p><pre><code>a1.sources = s1a1.sinks = k1 k2a1.channels = c1 c2a1.sources.s1.channels= c1 c2a1.sources.s1.type = execa1.sources.s1.command = tail -F /root/logs/userClick.loga1.sources.s1.interceptors=i1 i2a1.sources.s1.interceptors.i1.type=regex_filtera1.sources.r1.interceptors.i1.excludeEvents = falsea1.sources.s1.interceptors.i1.regex=\\{.*\\}a1.sources.s1.interceptors.i2.type=timestamp# channel1a1.channels.c1.type=memorya1.channels.c1.capacity=30000a1.channels.c1.transactionCapacity=1000# channel2a1.channels.c2.type=memorya1.channels.c2.capacity=30000a1.channels.c2.transactionCapacity=1000# k1a1.sinks.k1.type=hdfsa1.sinks.k1.channel=c1a1.sinks.k1.hdfs.path=hdfs://192.168.19.137:9000/user/hive/warehouse/profile.db/user_action/%Y-%m-%da1.sinks.k1.hdfs.useLocalTimeStamp = truea1.sinks.k1.hdfs.fileType=DataStreama1.sinks.k1.hdfs.writeFormat=Texta1.sinks.k1.hdfs.rollInterval=0a1.sinks.k1.hdfs.rollSize=10240a1.sinks.k1.hdfs.rollCount=0a1.sinks.k1.hdfs.idleTimeout=60# k2a1.sinks.k2.channel=c2a1.sinks.k2.type=org.apache.flume.sink.kafka.KafkaSinka1.sinks.k2.kafka.bootstrap.servers=192.168.19.137:9092a1.sinks.k2.kafka.topic=click-tracea1.sinks.k2.kafka.batchSize=20a1.sinks.k2.kafka.producer.requiredAcks=1</code></pre><p>添加 supervisor 配置</p><pre><code>[program:kafka]command=/bin/bash /root/toutiao_project/scripts/start_kafka.shuser=rootautorestart=trueredirect_stderr=truestdout_logfile=/root/logs/kafka.logloglevel=infostopsignal=KILLstopasgroup=truekillasgroup=true</code></pre><p>用 supervisorctl 启动后测试</p><h2 id="实时召回集业务"><a href="#实时召回集业务" class="headerlink" title="实时召回集业务"></a>实时召回集业务</h2><p>实时召回基于相似度的文章推荐</p><p>创建 online 文件夹，建立在线实时处理程序</p><ul><li>目的：对用户日志进行处理，实时达到求出相似文章，放入用户召回集合中</li><li>步骤：<ul><li>1、配置 spark streaming 信息</li><li>2、读取点击行为日志数据，获取相似文章列表</li><li>3、过滤历史文章集合</li><li>4、存入召回结果以及历史记录结果</li></ul></li></ul><p>happybase 和 kafka 对接 spark streaming 的配置</p><pre><code class="python"># 增加spark online 启动配置class DefaultConfig(object):    """默认的一些配置信息    """    SPARK_ONLINE_CONFIG = (        ("spark.app.name", "onlineUpdate"),  # 设置启动的spark的app名称，没有提供，将随机产生一个名称        ("spark.master", "yarn"),        ("spark.executor.instances", 4)    )# 添加sparkstreaming启动对接kafka的配置from pyspark import SparkConffrom pyspark.sql import SparkSessionfrom pyspark import SparkContextfrom pyspark.streaming import StreamingContextfrom pyspark.streaming.kafka import KafkaUtilsfrom setting.default import DefaultConfigimport happybase#  用于读取hbase缓存结果配置pool = happybase.ConnectionPool(size=10, host='hadoop-master', port=9090)# 1、创建confconf = SparkConf()conf.setAll(DefaultConfig.SPARK_ONLINE_CONFIG)# 建立spark session以及spark streaming contextsc = SparkContext(conf=conf)# 创建Streaming Contextstream_c = StreamingContext(sc, 60)# KAFKA配置KAFKA_SERVER = "192.168.19.137:9092"# 基于内容召回配置，用于收集用户行为，获取相似文章实时推荐similar_kafkaParams = {"metadata.broker.list": DefaultConfig.KAFKA_SERVER, "group.id": 'similar'}SIMILAR_DS = KafkaUtils.createDirectStream(stream_c, ['click-trace'], similar_kafkaParams)</code></pre><p>主代码</p><pre><code class="python">class OnlineRecall(object):"""在线处理计算平台"""    def __init__(self):        pass        def _update_online_cb(self):            """            通过点击行为更新用户的cb召回表中的online召回结果            :return:            """            def foreachFunc(rdd):                    for data in rdd.collect():                    logger.info(                        "{}, INFO: rdd filter".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))                    # 判断日志行为类型，只处理点击流日志                    if data["param"]["action"] in ["click", "collect", "share"]:                        # print(data)                        with pool.connection() as conn:                            try:                                # 相似文章表                                sim_table = conn.table("article_similar")                                    # 根据用户点击流日志涉及文章找出与之最相似文章(基于内容的相似)，选取TOP-k相似的作为召回推荐结果                                _dic = sim_table.row(str(data["param"]["articleId"]).encode(), columns=[b"similar"])                                _srt = sorted(_dic.items(), key=lambda obj: obj[1], reverse=True)  # 按相似度排序                                if _srt:                                        topKSimIds = [int(i[0].split(b":")[1]) for i in _srt[:self.k]]                                        # 根据历史推荐集过滤，已经给用户推荐过的文章                                    history_table = conn.table("history_recall")                                        _history_data = history_table.cells(                                        b"reco:his:%s" % data["param"]["userId"].encode(),                                        b"channel:%d" % data["channelId"]                                    )                                    # print("_history_data: ", _history_data)                                        history = []                                    if len(data) &gt;= 2:                                        for l in data[:-1]:                                            history.extend(eval(l))                                    else:                                        history = []                                        # 根据历史召回记录，过滤召回结果                                    recall_list = list(set(topKSimIds) - set(history_data))                                        # print("recall_list: ", recall_list)                                    logger.info("{}, INFO: store user:{} cb_recall data".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), data["param"]["userId"]))                                    if recall_list:                                        # 如果有推荐结果集，那么将数据添加到cb_recall表中，同时记录到历史记录表中                                        logger.info(                                            "{}, INFO: get online-recall data".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S')))                                        recall_table = conn.table("cb_recall")                                            recall_table.put(                                            b"recall:user:%s" % data["param"]["userId"].encode(),                                            {b"online:%d" % data["channelId"]: str(recall_list).encode()}                                        )                                            history_table.put(                                            b"reco:his:%s" % data["param"]["userId"].encode(),                                            {b"channel:%d" % data["channelId"]: str(recall_list).encode()}                                        )                            except Exception as e:                                logger.info("{}, WARN: {}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))                            finally:                                conn.close()                SIMILAR_DS.map(lambda x: json.loads(x[1])).foreachRDD(foreachFunc)                return None</code></pre><h1 id="推荐业务流实现与-AB-测试"><a href="#推荐业务流实现与-AB-测试" class="headerlink" title="推荐业务流实现与 AB 测试"></a>推荐业务流实现与 AB 测试</h1><ul><li><p>逻辑流程</p><ul><li>1、后端发送推荐请求，实时推荐系统拿到请求参数<ul><li>grpc对接</li></ul></li><li>2、根据用户进行ABTest分流<ul><li>ABTest实验中心，用于进行分流任务，方便测试调整不同的模型上线</li></ul></li><li>3、推荐中心服务<ul><li>根据用户在ABTest分配的算法进行召回服务和排序服务读取返回结果</li></ul></li><li>4、返回推荐结果和埋点参数封装</li></ul></li></ul><p><img src="/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230212160039176.png"></p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><ul><li>gRPC是由Google公司开源的高性能RPC框架。</li><li>gRPC支持多语言<br>gRPC原生使用C、Java、Go进行了三种实现，而C语言实现的版本进行封装后又支持C++、C#、Node、ObjC、 Python、Ruby、PHP等开发语言</li><li>gRPC支持多平台<br>支持的平台包括：Linux、Android、iOS、MacOS、Windows</li><li>gRPC的消息协议使用Google自家开源的Protocol Buffers协议机制（proto3） 序列化</li><li>gRPC的传输使用HTTP/2标准，支持双向流和连接多路复用</li></ul><h3 id="创建user-reco-proto协议文件"><a href="#创建user-reco-proto协议文件" class="headerlink" title="创建user_reco.proto协议文件"></a>创建user_reco.proto协议文件</h3><ul><li>用户刷新feed流接口<ul><li>user_recommend(User) returns (Track)</li></ul></li><li>文章相似(猜你喜欢)接口<ul><li>article_recommend(Article) returns(Similar)</li></ul></li></ul><p>编写grpc_tools.protoc</p><pre><code class="shell">syntax = "proto3";message User {    string user_id = 1;    int32 channel_id = 2;    int32 article_num = 3;    int64 time_stamp = 4;}// int32 ---&gt; int64 article_idmessage Article {    int64 article_id = 1;    int32 article_num = 2;}message param2 {    string click = 1;    string collect = 2;    string share = 3;    string read = 4;}message param1 {    int64 article_id = 1;    param2 params = 2;}message Track {    string exposure = 1;    repeated param1 recommends = 2;    int64 time_stamp = 3;}message Similar {    repeated int64 article_id = 1;}service UserRecommend {    // feed recommend    rpc user_recommend(User) returns (Track) {}    rpc article_recommend(Article) returns(Similar) {}}</code></pre><p>通过命令生成</p><pre><code class="shell">python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. user_reco.proto</code></pre><h3 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h3><pre><code class="python"># route.py# 基于用户推荐的rpc服务推荐# 定义指定的rpc服务输入输出参数格式protoRPC_SERVER = '192.168.19.137:9999'class UserRecommendServicer(user_reco_pb2_grpc.UserRecommendServicer):    """    对用户进行技术文章推荐    """    def user_recommend(self, request, context):        """        用户feed流推荐        :param request:        :param context:        :return:        """        # 选择C4组合        user_id = request.user_id        channel_id = request.channel_id        article_num = request.article_num        time_stamp = request.time_stamp        # 解析参数，并进行推荐中心推荐(暂时使用假数据替代)        class Temp(object):            user_id = -10            algo = 'test'            time_stamp = -10        tp = Temp()        tp.user_id = user_id        tp.time_stamp = time_stamp        _track = add_track([], tp)        # 解析返回参数到rpc结果参数        # 参数如下        # [       {"article_id": 1, "param": {"click": "", "collect": "", "share": "", 'detentionTime':''}},        #         {"article_id": 2, "param": {"click": "", "collect": "", "share": "", 'detentionTime':''}},        #         {"article_id": 3, "param": {"click": "", "collect": "", "share": "", 'detentionTime':''}},        #         {"article_id": 4, "param": {"click": "", "collect": "", "share": "", 'detentionTime':''}}        #     ]        # 第二个rpc参数        _param1 = []        for _ in _track['recommends']:            # param的封装            _params = user_reco_pb2.param2(click=_['param']['click'],                                           collect=_['param']['collect'],                                           share=_['param']['share'],                                           read=_['param']['read'])            _p2 = user_reco_pb2.param1(article_id=_['article_id'], params=_params)            _param1.append(_p2)        # param        return user_reco_pb2.Track(exposure=_track['param'], recommends=_param1, time_stamp=_track['timestamp'])#    def article_recommend(self, request, context):#        """#       文章相似推荐#       :param request:#       :param context:#       :return:#       """#       # 获取web参数#       article_id = request.article_id#       article_num = request.article_num##        # 进行文章相似推荐,调用推荐中心的文章相似#       _article_list = article_reco_list(article_id, article_num, 105)##       # rpc参数封装#       return user_reco_pb2.Similar(article_id=_article_list)def add_track(res, temp):    """    封装埋点参数    :param res: 推荐文章id列表    :param cb: 合并参数    :param rpc_param: rpc参数    :return: 埋点参数        文章列表参数        单文章参数    """    # 添加埋点参数    track = {}    # 准备曝光参数    # 全部字符串形式提供，在hive端不会解析问题    _exposure = {"action": "exposure", "userId": temp.user_id, "articleId": json.dumps(res),                 "algorithmCombine": temp.algo}    track['param'] = json.dumps(_exposure)    track['recommends'] = []    # 准备其它点击参数    for _id in res:        # 构造字典        _dic = {}        _dic['article_id'] = _id        _dic['param'] = {}        # 准备click参数        _p = {"action": "click", "userId": temp.user_id, "articleId": str(_id),              "algorithmCombine": temp.algo}        _dic['param']['click'] = json.dumps(_p)        # 准备collect参数        _p["action"] = 'collect'        _dic['param']['collect'] = json.dumps(_p)        # 准备share参数        _p["action"] = 'share'        _dic['param']['share'] = json.dumps(_p)        # 准备detentionTime参数        _p["action"] = 'read'        _dic['param']['read'] = json.dumps(_p)        track['recommends'].append(_dic)    track['timestamp'] = temp.time_stamp    return trackdef serve():    # 多线程服务器    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))    # 注册本地服务    user_reco_pb2_grpc.add_UserRecommendServicer_to_server(UserRecommendServicer(), server)    # 监听端口    server.add_insecure_port(DefaultConfig.RPC_SERVER)    # 开始接收请求进行服务    server.start()    # 使用 ctrl+c 可以退出服务    _ONE_DAY_IN_SECONDS = 60 * 60 * 24    try:        while True:            time.sleep(_ONE_DAY_IN_SECONDS)    except KeyboardInterrupt:        server.stop(0)if __name__ == '__main__':    # 测试grpc服务    serve()</code></pre><p>客户端测试代码：</p><pre><code class="python">import osimport sysBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, os.path.join(BASE_DIR))from abtest import user_reco_pb2_grpcfrom abtest import user_reco_pb2import grpcfrom setting.default import DefaultConfigimport timedef test():    article_dict = {}    # 构造传入数据    req_article = user_reco_pb2.User()    req_article.user_id = '1115629498121846784'    req_article.channel_id = 18    req_article.article_num = 10    req_article.time_stamp = int(time.time() * 1000)    # req_article.time_stamp = 1555573069870    with grpc.insecure_channel(DefaultConfig.RPC_SERVER) as rpc_cli:        print('''''')        try:            stub = user_reco_pb2_grpc.UserRecommendStub(rpc_cli)            resp = stub.user_recommend(req_article)        except Exception as e:            print(e)            article_dict['param'] = []        else:            # 解析返回结果参数            article_dict['exposure_param'] = resp.exposure            reco_arts = resp.recommends            reco_art_param = []            reco_list = []            for art in reco_arts:                reco_art_param.append({                    'artcle_id': art.article_id,                    'params': {                        'click': art.params.click,                        'collect': art.params.collect,                        'share': art.params.share,                        'read': art.params.read                    }                })                reco_list.append(art.article_id)            article_dict['param'] = reco_art_param            # 文章列表以及参数（曝光参数 以及 每篇文章的点击等参数）            print(reco_list, article_dict)if __name__ == '__main__':    test()</code></pre><h2 id="通过哈希分桶进行流量切分"><a href="#通过哈希分桶进行流量切分" class="headerlink" title="通过哈希分桶进行流量切分"></a>通过哈希分桶进行流量切分</h2><pre><code class="python">def feed_recommend(user_id, channel_id, article_num, time_stamp):    """    1、根据web提供的参数，进行分流    2、找到对应的算法组合之后，去推荐中心调用不同的召回和排序服务    3、进行埋点参数封装    :param user_id:用户id    :param article_num:推荐文章个数    :return: track:埋点参数结果: 参考上面埋点参数组合    """    #  产品前期推荐由于较少的点击行为，所以去做 用户冷启动 + 文章冷启动    # 用户冷启动：'推荐'频道：热门频道的召回+用户实时行为画像召回（在线的不保存画像）  'C2'组合    #            # 其它频道：热门召回 + 新文章召回   'C1'组合    # 定义返回参数的类    class TempParam(object):        user_id = -10        channel_id = -10        article_num = -10        time_stamp = -10        algo = ""    temp = TempParam()    temp.user_id = user_id    temp.channel_id = channel_id    temp.article_num = article_num    # 请求的时间戳大小    temp.time_stamp = time_stamp    # 先读取缓存数据redis+待推荐hbase结果    # 如果有返回并加上埋点参数    # 并且写入hbase 当前推荐时间戳用户（登录和匿名）的历史推荐文章列表    # 传入用户id为空的直接召回结果    if temp.user_id == "":        temp.algo = ""        return add_track([], temp)    # 进行分桶实现分流，制定不同的实验策略    bucket = hashlib.md5(user_id.encode()).hexdigest()[:1]    if bucket in RAParam.BYPASS[0]['Bucket']:        temp.algo = RAParam.BYPASS[0]['Strategy']    else:        temp.algo = RAParam.BYPASS[1]['Strategy']    # 推荐服务中心推荐结果(这里做测试)    track = add_track([], temp)    return track</code></pre><h2 id="推荐服务中心"><a href="#推荐服务中心" class="headerlink" title="推荐服务中心"></a>推荐服务中心</h2><ul><li>根据时间戳<ul><li>时间戳T小于HBASE历史推荐记录，则获取历史记录，返回该时间戳T上次的时间戳T-1</li><li>时间戳T大于HBASE历史推荐记录，则获取新推荐，则获取HBASE数据库中最近的一次时间戳<ul><li>如果有缓存，从缓存中拿，并且写入推荐历史表中</li><li>如果没有缓存，就进行一次指定算法组合的召回结果读取，排序，然后写入待推荐wait_recommend中，其中推荐出去的放入历史推荐表中</li></ul></li></ul></li></ul><h3 id="推荐中心业务逻辑"><a href="#推荐中心业务逻辑" class="headerlink" title="推荐中心业务逻辑"></a>推荐中心业务逻辑</h3><pre><code class="python">def feed_recommend_logic(self, temp):    """推荐流业务逻辑    :param temp:ABTest传入的业务请求参数    """    # 判断用请求的时间戳大小决定获取历史记录还是刷新推荐文章    try:        last_stamp = self.hbu.get_table_row('history_recommend', 'reco:his:{}'.format(temp.user_id).encode(),                                            'channel:{}'.format(temp.channel_id).encode(), include_timestamp=True)[1]        logger.info("{} INFO get user_id:{} channel:{} history last_stamp".format(            datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))    except Exception as e:        logger.warning("{} WARN read history recommend exception:{}".format(            datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))        last_stamp = 0    # 如果小于，走一遍正常的推荐流程，缓存或者召回排序    logger.info("{} INFO history last_stamp:{},temp.time_stamp:{}".                format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), last_stamp, temp.time_stamp))    if last_stamp &lt; temp.time_stamp:        # 获取        res = redis_cache.get_reco_from_cache(temp, self.hbu)        # 如果没有，然后走一遍算法推荐 召回+排序，同时写入到hbase待推荐结果列表        if not res:            logger.info("{} INFO get user_id:{} channel:{} recall/sort data".                        format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))            res = self.user_reco_list(temp)        temp.time_stamp = int(last_stamp)        track = add_track(res, temp)    else:        logger.info("{} INFO read user_id:{} channel:{} history recommend data".format(            datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))        try:            row = self.hbu.get_table_cells('history_recommend',                                      'reco:his:{}'.format(temp.user_id).encode(),                                      'channel:{}'.format(temp.channel_id).encode(),                                      timestamp=temp.time_stamp + 1,                                      include_timestamp=True)        except Exception as e:            logger.warning("{} WARN read history recommend exception:{}".format(                datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))            row = []            res = []        # 1、如果没有历史数据，返回时间戳0以及结果空列表        # 2、如果历史数据只有一条，返回这一条历史数据以及时间戳正好为请求时间戳，修改时间戳为0        # 3、如果历史数据多条，返回最近一条历史数据，然后返回        if not row:            temp.time_stamp = 0            res = []        elif len(row) == 1 and row[0][1] == temp.time_stamp:            res = eval(row[0][0])            temp.time_stamp = 0        elif len(row) &gt;= 2:            res = eval(row[0][0])            temp.time_stamp = int(row[1][1])        res = list(map(int, res))        logger.info(            "{} INFO history:{}, {}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), res, temp.time_stamp))        track = add_track(res, temp)        # 曝光参数设置为空        track['param'] = ''    return track</code></pre><h3 id="获取用户召回结果"><a href="#获取用户召回结果" class="headerlink" title="获取用户召回结果"></a>获取用户召回结果</h3><pre><code class="python">  def user_reco_list(self, temp):        """        获取用户的召回结果进行推荐        :param temp:        :return:        """        reco_set = []        # 1、循环算法组合参数，遍历不同召回结果进行过滤        for _num in RAParam.COMBINE[temp.algo][1]:            # 进行每个召回结果的读取100,101,102,103,104            if _num == 103:                # 新文章召回读取                _res = self.recall_service.read_redis_new_article(temp.channel_id)                reco_set = list(set(reco_set).union(set(_res)))            elif _num == 104:                # 热门文章召回读取                _res = self.recall_service.read_redis_hot_article(temp.channel_id)                reco_set = list(set(reco_set).union(set(_res)))            else:                _res = self.recall_service.\                    read_hbase_recall_data(RAParam.RECALL[_num][0],                                           'recall:user:{}'.format(temp.user_id).encode(),                                           '{}:{}'.format(RAParam.RECALL[_num][1], temp.channel_id).encode())                # 进行合并某个协同过滤召回的结果                reco_set = list(set(reco_set).union(set(_res)))        # reco_set都是新推荐的结果，进行过滤        history_list = []        try:            data = self.hbu.get_table_cells('history_recommend',                                            'reco:his:{}'.format(temp.user_id).encode(),                                            'channel:{}'.format(temp.channel_id).encode())            for _ in data:                history_list = list(set(history_list).union(set(eval(_))))            logger.info("{} INFO filter user_id:{} channel:{} history data".format(                datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))        except Exception as e:            logger.warning(                "{} WARN filter history article exception:{}".format(datetime.now().                                                                     strftime('%Y-%m-%d %H:%M:%S'), e))        # 如果0号频道有历史记录，也需要过滤        try:            data = self.hbu.get_table_cells('history_recommend',                                            'reco:his:{}'.format(temp.user_id).encode(),                                            'channel:{}'.format(0).encode())            for _ in data:                history_list = list(set(history_list).union(set(eval(_))))            logger.info("{} INFO filter user_id:{} channel:{} history data".format(                datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, 0))        except Exception as e:            logger.warning(                "{} WARN filter history article exception:{}".format(datetime.now().                                                                     strftime('%Y-%m-%d %H:%M:%S'), e))        # 过滤操作 reco_set 与history_list进行过滤        reco_set = list(set(reco_set).difference(set(history_list)))        # 排序代码逻辑        # _sort_num = RAParam.COMBINE[temp.algo][2][0]        # reco_set = sort_dict[RAParam.SORT[_sort_num]](reco_set, temp, self.hbu)        # 如果没有内容，直接返回        if not reco_set:            return reco_set        else:            # 类型进行转换            reco_set = list(map(int, reco_set))            # 跟后端需要推荐的文章数量进行比对 article_num            # article_num &gt; reco_set            if len(reco_set) &lt;= temp.article_num:                res = reco_set            else:                # 之取出推荐出去的内容                res = reco_set[:temp.article_num]                # 剩下的推荐结果放入wait_recommend等待下次帅新的时候直接推荐                self.hbu.get_table_put('wait_recommend',                                       'reco:{}'.format(temp.user_id).encode(),                                       'channel:{}'.format(temp.channel_id).encode(),                                       str(reco_set[temp.article_num:]).encode(),                                       timestamp=temp.time_stamp)                logger.info(                    "{} INFO put user_id:{} channel:{} wait data".format(                        datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))            # 放入历史记录表当中            self.hbu.get_table_put('history_recommend',                                   'reco:his:{}'.format(temp.user_id).encode(),                                   'channel:{}'.format(temp.channel_id).encode(),                                   str(res).encode(),                                   timestamp=temp.time_stamp)            # 放入历史记录日志            logger.info(                "{} INFO store recall/sorted user_id:{} channel:{} history_recommend data".format(                    datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))            return res</code></pre><h3 id="在线预测"><a href="#在线预测" class="headerlink" title="在线预测"></a>在线预测</h3><p>除了对召回集进行排序以外，还可以在在线平台上使用离线训练好的点击率模型，得到高点击召回集。</p><pre><code class="python">def lr_sort_service(reco_set, temp, hbu):    """    排序返回推荐文章    :param reco_set:召回合并过滤后的结果    :param temp: 参数    :param hbu: Hbase工具    :return:    """    # 排序    # 1、读取用户特征中心特征    try:        user_feature = eval(hbu.get_table_row('ctr_feature_user',                                              '{}'.format(temp.user_id).encode(),                                              'channel:{}'.format(temp.channel_id).encode()))        logger.info("{} INFO get user user_id:{} channel:{} profile data".format(            datetime.now().strftime('%Y-%m-%d %H:%M:%S'), temp.user_id, temp.channel_id))    except Exception as e:        user_feature = []    if user_feature:        # 2、读取文章特征中心特征        result = []        for article_id in reco_set:            try:                article_feature = eval(hbu.get_table_row('ctr_feature_article',                                                         '{}'.format(article_id).encode(),                                                         'article:{}'.format(article_id).encode()))            except Exception as e:                article_feature = [0.0] * 111            f = []            # 第一个channel_id            f.extend([article_feature[0]])            # 第二个article_vector            f.extend(article_feature[11:])            # 第三个用户权重特征            f.extend(user_feature)            # 第四个文章权重特征            f.extend(article_feature[1:11])            vector = DenseVector(f)            result.append([temp.user_id, article_id, vector])        # 4、预测并进行排序是筛选        df = pd.DataFrame(result, columns=["user_id", "article_id", "features"])        test = SORT_SPARK.createDataFrame(df)        # 加载逻辑回归模型        model = LogisticRegressionModel.load("hdfs://hadoop-master:9000/headlines/models/LR.obj")        predict = model.transform(test)        def vector_to_double(row):            return float(row.article_id), float(row.probability[1])        res = predict.select(['article_id', 'probability']).rdd.map(vector_to_double).toDF(            ['article_id', 'probability']).sort('probability', ascending=False)        article_list = [i.article_id for i in res.collect()]        logger.info("{} INFO sorting user_id:{} recommend article".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'),                                                                          temp.user_id))        # 排序后，只将排名在前100个文章ID返回给用户推荐        if len(article_list) &gt; 100:            article_list = article_list[:100]        reco_set = list(map(int, article_list))    return reco_set</code></pre><h3 id="多路召回"><a href="#多路召回" class="headerlink" title="多路召回"></a>多路召回</h3><pre><code class="python">import osimport sysBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, os.path.join(BASE_DIR))from server import redis_clientfrom server import poolimport loggingfrom datetime import datetimefrom abtest.utils import HBaseUtilslogger = logging.getLogger('recommend')class ReadRecall(object):    """读取召回集的结果    """    def __init__(self):        self.client = redis_client        self.hbu = HBaseUtils(pool)    def read_hbase_recall_data(self, table_name, key_format, column_format):        """获取指定用户的对应频道的召回结果,在线画像召回，离线画像召回，离线协同召回        :return:        """        # 获取family对应的值        # 数据库中的键都是bytes类型，所以需要进行编码相加        # 读取召回结果多个版本合并        recall_list = []        try:            data = self.hbu.get_table_cells(table_name, key_format, column_format)            for _ in data:                recall_list = list(set(recall_list).union(set(eval(_))))            # 读取所有这个用户的在线推荐的版本，清空该频道的数据            # self.hbu.get_table_delete(table_name, key_format, column_format)        except Exception as e:            logger.warning(                "{} WARN read recall data exception:{}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))        return recall_list    def read_redis_new_data(self, channel_id):        """获取redis新文章结果        :param channel_id:        :return:        """        # format结果        logger.info("{} INFO read channel:{} new recommend data".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), channel_id))        _key = "ch:{}:new".format(channel_id)        try:            res = self.client.zrevrange(_key, 0, -1)        except redis.exceptions.ResponseError as e:            logger.warning("{} WARN read new article exception:{}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))            res = []        return list(map(int, res))    def read_redis_hot_data(self, channel_id):        """获取redis热门文章结果        :param channel_id:        :return:        """        # format结果        logger.info("{} INFO read channel:{} hot recommend data".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), channel_id))        _key = "ch:{}:hot".format(channel_id)        try:            _res = self.client.zrevrange(_key, 0, -1)        except redis.exceptions.ResponseError as e:            logger.warning("{} WARN read hot article exception:{}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))            _res = []        # 每次返回前50热门文章        res = list(map(int, _res))        if len(res) &gt; 50:            res = res[:50]        return res    def read_hbase_article_similar(self, table_name, key_format, article_num):        """获取文章相似结果        :param article_id: 文章id        :param article_num: 文章数量        :return:        """        # 第一种表结构方式测试：        # create 'article_similar', 'similar'        # put 'article_similar', '1', 'similar:1', 0.2        # put 'article_similar', '1', 'similar:2', 0.34        try:            _dic = self.hbu.get_table_row(table_name, key_format)            res = []            _srt = sorted(_dic.items(), key=lambda obj: obj[1], reverse=True)            if len(_srt) &gt; article_num:                _srt = _srt[:article_num]            for _ in _srt:                res.append(int(_[0].decode().split(':')[1]))        except Exception as e:            logger.error("{} ERROR read similar article exception: {}".format(datetime.now().strftime('%Y-%m-%d %H:%M:%S'), e))            res = []        return resif __name__ == '__main__':    rr = ReadRecall()    print(rr.read_hbase_article_similar('article_similar', b'13342', 10))    print(rr.read_hbase_recall_data('cb_recall', b'recall:user:1115629498121846784', b'als:18'))    # rr = ReadRecall()    # print(rr.read_redis_new_data(18))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/02/13/%E5%A4%B4%E6%9D%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE/image-20230211193156286.png&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="BigData" scheme="http://example.com/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>大数据框架简介</title>
    <link href="http://example.com/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</id>
    <published>2023-02-11T05:44:39.000Z</published>
    <updated>2023-02-13T05:41:54.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop：分布式系统框架"><a href="#Hadoop：分布式系统框架" class="headerlink" title="Hadoop：分布式系统框架"></a>Hadoop：分布式系统框架</h1><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/image-20230201202112535.png"></p><h2 id="HDFS：分布式文件系统"><a href="#HDFS：分布式文件系统" class="headerlink" title="HDFS：分布式文件系统"></a>HDFS：分布式文件系统</h2><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/image-20230201203516037.png"></p><blockquote><p>TIP: HDFS中的block大小为64MB，默认保存3份</p></blockquote><h2 id="YARN：分布式资源调度器"><a href="#YARN：分布式资源调度器" class="headerlink" title="YARN：分布式资源调度器"></a>YARN：分布式资源调度器</h2><p>核心思想：JobTracker和TaskTacker进行分离<br><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/image-20230201203912441.png"></p><p>包含ResourceManager，ApplicationMaster，Nodemanager，Container，Client</p><h2 id="MapReduce：分布式计算框架"><a href="#MapReduce：分布式计算框架" class="headerlink" title="MapReduce：分布式计算框架"></a>MapReduce：分布式计算框架</h2><p><img src="/2023/02/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/image-20230201202455615.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hadoop：分布式系统框架&quot;&gt;&lt;a href=&quot;#Hadoop：分布式系统框架&quot; class=&quot;headerlink&quot; title=&quot;Hadoop：分布式系统框架&quot;&gt;&lt;/a&gt;Hadoop：分布式系统框架&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2023/02/11/</summary>
      
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="BigData" scheme="http://example.com/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>投资的心态</title>
    <link href="http://example.com/2022/06/23/%E6%8A%95%E8%B5%84%E7%9A%84%E5%BF%83%E6%80%81/"/>
    <id>http://example.com/2022/06/23/%E6%8A%95%E8%B5%84%E7%9A%84%E5%BF%83%E6%80%81/</id>
    <published>2022-06-23T08:50:34.000Z</published>
    <updated>2023-02-13T05:45:32.316Z</updated>
    
    <content type="html"><![CDATA[<p>普通投资者把精力花在学习投资知识和策略上，有什么意义呢？什么是健康的投资心态？从投资这件事上如何历练正确的积极的心态，以对我们的人生有所帮助？</p><h2 id="避免的陷阱"><a href="#避免的陷阱" class="headerlink" title="避免的陷阱"></a>避免的陷阱</h2><ol><li>时间沉没成本<br>我已经花了多少时间在这上面？这部分投入换算成金钱，增加到我的亏损上，最终结果应当还是盈余。</li><li>未获得的和已经失去的</li><li>短线的痛苦</li></ol><h2 id="正确的心态"><a href="#正确的心态" class="headerlink" title="正确的心态"></a>正确的心态</h2><ol><li>长远眼光</li><li>市场知识的学习</li><li>人性的学习</li><li>避免生活中的陷阱</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;普通投资者把精力花在学习投资知识和策略上，有什么意义呢？什么是健康的投资心态？从投资这件事上如何历练正确的积极的心态，以对我们的人生有所帮助？&lt;/p&gt;
&lt;h2 id=&quot;避免的陷阱&quot;&gt;&lt;a href=&quot;#避免的陷阱&quot; class=&quot;headerlink&quot; title=&quot;避免的</summary>
      
    
    
    
    <category term="freetime" scheme="http://example.com/categories/freetime/"/>
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>GNN概述</title>
    <link href="http://example.com/2022/04/29/GNN%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/04/29/GNN%E6%A6%82%E8%BF%B0/</id>
    <published>2022-04-29T10:19:16.000Z</published>
    <updated>2022-10-25T04:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Graph-embedding"><a href="#Graph-embedding" class="headerlink" title="Graph embedding"></a>Graph embedding</h1><h2 id="2-1-deepwalk"><a href="#2-1-deepwalk" class="headerlink" title="2.1 deepwalk"></a>2.1 deepwalk</h2><p>从某个节点出发随机游走，得到若干个序列，用skip-gram计算每个节点的embedding信息</p><h2 id="2-2-LINE"><a href="#2-2-LINE" class="headerlink" title="2.2 LINE"></a>2.2 LINE</h2><p>一阶相似性：直接相连的两节点相似</p><p>二阶相似性：有大量共同邻居的两个不相连节点相似</p><p>相似度高的节点会在embedding后有更短的欧氏距离</p><p>一阶和二阶直接拼接为节点的向量</p><span id="more"></span><h2 id="2-3-Node2vec"><a href="#2-3-Node2vec" class="headerlink" title="2.3 Node2vec"></a>2.3 Node2vec</h2><p>有策略的随机游走</p><p>深度优先得到节点的社团相似性（上图）</p><p>广度优先得到节点的结构等价性（下图）</p><p><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20210818171416928.png"></p><h2 id="2-4-Struc2vec"><a href="#2-4-Struc2vec" class="headerlink" title="2.4 Struc2vec"></a>2.4 Struc2vec</h2><ol><li><p>计算节点n阶邻居度的序列，</p></li><li><p>求两序列的相似度</p></li><li><p>得到两节点的结构相似性</p></li></ol><h2 id="2-5-SDNE"><a href="#2-5-SDNE" class="headerlink" title="2.5 SDNE"></a>2.5 SDNE</h2><p>采用多个非线性层捕获一阶二阶相似性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20210818173631288.png"></p><h1 id="两类学习"><a href="#两类学习" class="headerlink" title="两类学习"></a>两类学习</h1><ul><li><strong>归纳学习（Inductive Learning）：</strong> 先从训练样本中学习到一定的模式，然后利用其对测试样本进行预测（即首先从特殊到一般，然后再从一般到特殊），这类模型如常见的<a href="https://www.zhihu.com/search?q=%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%A8%A1%E5%9E%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:34232818%7D">贝叶斯模型</a>。</li><li><strong>直推学习（Transductive Learning）：</strong> 先观察特定的训练样本，然后对特定的测试样本做出预测（从特殊到特殊），这类模型如k近邻、SVM等。</li></ul><h1 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h1><ul><li><strong>GCN的基本思想：</strong> 把一个节点在图中的高纬度邻接信息降维到一个低维的向量表示。</li><li><strong>GCN的优点：</strong> 可以捕捉graph的全局信息，从而很好地表示node的特征。</li><li><strong>GCN的缺点：</strong> Transductive learning的方式，需要把所有节点都参与训练才能得到<a href="https://www.zhihu.com/search?q=node+embedding&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:74242097%7D">node embedding</a>，无法快速得到新node的embedding。</li></ul><p>常用字母对应:</p><table><thead><tr><th>名称</th><th>字母</th></tr></thead><tbody><tr><td>度矩阵（对角阵）</td><td>D</td></tr><tr><td>邻接矩阵（01阵）</td><td>A</td></tr></tbody></table><p>$$<br>\tilde{A}=A+I_N<br>$$<br>$$<br>\tilde{D}=D+I_N<br>$$<br>$$<br>H^{(l+1)}=\sigma(\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}H^{(l)}W^{(l)})<br>$$</p><p>$\tilde{A}H$聚合了节点自身和邻居的信息，$\tilde{D}^{-\frac{1}{2}}$起到归一化的作用。</p><p>归一化之后的$\tilde{A}$ 可记为：<br>$$<br>\hat{A}=\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}<br>$$</p><h2 id="训练方式"><a href="#训练方式" class="headerlink" title="训练方式"></a>训练方式</h2><h3 id="端到端"><a href="#端到端" class="headerlink" title="端到端"></a>端到端</h3><p>$$<br>Z=f(X,A)=softmax(\hat{A},ReLU(\hat{A}HW^{(0)})W^{(1)})<br>$$</p><h2 id="嵌入-MLP"><a href="#嵌入-MLP" class="headerlink" title="嵌入+MLP"></a>嵌入+MLP</h2><h1 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a>GraphSAGE</h1><p><strong>思想：学习一个节点的信息是怎么通过其邻居节点的特征聚合而来的</strong><br>$$<br>h^k_{N(v)}=Agg({h^{k-1}_u},\forall u\in N(v))<br>$$</p><p>$$<br>h_v^k=\sigma(W^k \cdot Concat(h^{k-1}<em>v,h^k</em>{N(v)}) )<br>$$</p><p>$N(v)$表示节点 $v$ 的邻居节点集合，$Agg$()表示某个聚合函数。$k$代表层数。每一轮结束后进行归一化：<br>$$<br>h_v^k=h_v^k/\Vert h_v^k \Vert _2<br>$$</p><h2 id="邻居采样"><a href="#邻居采样" class="headerlink" title="邻居采样"></a>邻居采样</h2><pre><code class="python">if len(neighbors) &gt;= self.max_degree:    neighbors=np.random.choice(neighbors, self.max_degree, replace=False)# 数量不足将有放回的采样elif len(neighbors) &lt; self.max_degree:    neighbors=np.random.choice(neighbors, self.max_degree, replace=True)</code></pre><p><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20211209161858990.png"></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>需要满足输入排列不变性，如</p><ul><li>Mean()</li><li><strong>GCN aggregator</strong> 比mean()多算一个自身特征</li><li>LSTM</li><li>Pooling</li></ul><p>$$<br>Agg_k^{pool}=max({ \sigma(Wh_u^k+b)})<br>$$</p><h2 id="Minibatch"><a href="#Minibatch" class="headerlink" title="Minibatch"></a>Minibatch</h2><p>即先采样把不需要用到的节点删除</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>让临近的节点拥有相似的表示，反之应该表示大不相同</p><p><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/v2-9c473f5e242f8db158854d4e5e036b9c_r.jpg"></p><h1 id="GAT"><a href="#GAT" class="headerlink" title="GAT"></a>GAT</h1><p>$$<br>\alpha_{ij}=\frac{exp(LeakyReLu(\vec a^T[\boldsymbol W\vec h_i\Vert \boldsymbol W\vec h_j ]))}{\sum _{k \in N_i}exp(LeakyReLu(\vec a^T[\boldsymbol W\vec h_i\Vert \boldsymbol  W \vec h_k ]))}<br>$$</p><blockquote><p>相当于在聚合前计算了权重。如果$\vec a$是全1向量，那么这个权重就由邻居节点各自的特征值大小决定。<br>$$<br>\vec h_i^\prime=\sigma\left(\sum_{j\in N_i}\alpha_{ij} \boldsymbol W\vec h_j\right)<br>$$</p></blockquote><h2 id="multi-head-attention"><a href="#multi-head-attention" class="headerlink" title="multi-head attention"></a>multi-head attention</h2><p>$$<br>\vec h_i^\prime=\sigma\left(\sum_{j\in N_i}\alpha_{ij}^k \boldsymbol W^k\vec h_j\right)<br>$$</p><h1 id="PATCH-SAN"><a href="#PATCH-SAN" class="headerlink" title="PATCH-SAN"></a>PATCH-SAN</h1><h1 id="HAN"><a href="#HAN" class="headerlink" title="HAN"></a>HAN</h1><p>异构图：节点和边的类型之和大于2<br>元路径：按照某种类型pattern的路径（有向），不同的元路径揭示了不同的<strong>语义信息</strong><br>基于元路径的邻居：以某种元路径连接到节点i的所有节点<br>所以，在根据元路径邻居分配注意力的时候，可以依据不同类型的元路径分配权重<br><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20211223171241963.png"></p><h2 id="Node-level-Attention"><a href="#Node-level-Attention" class="headerlink" title="Node-level Attention"></a>Node-level Attention</h2><ol><li>根据某一类型元路径，异构图转为同构图</li><li>类似于GAT<br>$$<br> e_{ij}^\Phi=att_{node}(h^\prime_i,h^\prime_j;\Phi)<br>$$<br>$$<br>\alpha_{ij}^\Phi=softmax(e_{ij}^\Phi)<br>$$<br>$$<br>z_{i}^\Phi=\sigma(\sum_{j \in{\mathcal {N}}<em>i^\Phi}\alpha</em>{ij}^\Phi \cdot  h^\prime_j)<br>$$</li></ol><h2 id="Semantic-level-Attention"><a href="#Semantic-level-Attention" class="headerlink" title="Semantic-level Attention"></a>Semantic-level Attention</h2><p>$$<br> w_{\Phi_i}=\frac{1}{|{\mathcal{V}}|} \sum_{i\in{\mathcal{V}}}q^T\cdot\tanh(W\cdot z_i^\Phi+b)<br>$$<br>$$<br> \beta_{\Phi_i}=\frac{exp(w_{\Phi_i})}{\sum_{i=1}^Pexp(w_{\Phi_i})}<br>$$<br>$$<br> Z=\sum_{i=1}^{P}\beta_{\Phi_i}\cdot Z_{\Phi_i}<br>$$</p><h1 id="GTN"><a href="#GTN" class="headerlink" title="GTN"></a>GTN</h1><p><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20211223194418292.png"></p><ol><li>用$D^{-1}Q_1Q_2$归一化</li><li>为了保留图本身的性质，给点边关系集增加一个单位阵$I$这样和A相乘时还是A。</li><li>矩阵相乘后去掉对角线</li></ol><h1 id="metapath2vec"><a href="#metapath2vec" class="headerlink" title="metapath2vec"></a>metapath2vec</h1><p>元路径随机游走<br>对称的元路径效果更好<br>$$<br>p(v^{i+1}|v_t^i,{\mathcal{P}})=<br>\begin{cases}<br>\frac{1}{|N_{t+1}(v_t^i)|}, &amp; \text{$(v^{i+1},v^i)\in E,\phi(v^{i+1})=t+1$}\[2ex]<br>0, &amp; \text{other situation}\<br>\end{cases}<br>$$<br>上述公式表明，在游走到某节点$v_t$的情况下，下一节点在满足一下两个条件的节点中等概率选择：</p><ol><li>和节点$v_t$有边连接</li><li>是元路径规定的下一个节点的类型</li></ol><blockquote><p>获得随机游走序列之后，和deepwalk一样输入skip-gram模型训练</p></blockquote><h1 id="GATNE"><a href="#GATNE" class="headerlink" title="GATNE"></a>GATNE</h1><ol><li>相比metapath2vec，增加了边类型不同的情况</li><li>base-embedding+edge-embedding<br><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20211226200105763.png"><blockquote><p>用函数逼近器得到归纳学习的效果<br><img src="/2022/04/29/GNN%E6%A6%82%E8%BF%B0/image-20211226204804890.png"></p></blockquote></li></ol><h1 id="BiNE"><a href="#BiNE" class="headerlink" title="BiNE"></a>BiNE</h1><p> 给显式和隐式关系分别赋予不同的权重。<br> 显式关系：直接的连边，A-B或A-A<br> 隐式关系：共同邻居，类似于元路径的A-B-A</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.bilibili.com/video/BV1K5411H7EQ?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">B站某大佬</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Graph-embedding&quot;&gt;&lt;a href=&quot;#Graph-embedding&quot; class=&quot;headerlink&quot; title=&quot;Graph embedding&quot;&gt;&lt;/a&gt;Graph embedding&lt;/h1&gt;&lt;h2 id=&quot;2-1-deepwalk&quot;&gt;&lt;a href=&quot;#2-1-deepwalk&quot; class=&quot;headerlink&quot; title=&quot;2.1 deepwalk&quot;&gt;&lt;/a&gt;2.1 deepwalk&lt;/h2&gt;&lt;p&gt;从某个节点出发随机游走，得到若干个序列，用skip-gram计算每个节点的embedding信息&lt;/p&gt;
&lt;h2 id=&quot;2-2-LINE&quot;&gt;&lt;a href=&quot;#2-2-LINE&quot; class=&quot;headerlink&quot; title=&quot;2.2 LINE&quot;&gt;&lt;/a&gt;2.2 LINE&lt;/h2&gt;&lt;p&gt;一阶相似性：直接相连的两节点相似&lt;/p&gt;
&lt;p&gt;二阶相似性：有大量共同邻居的两个不相连节点相似&lt;/p&gt;
&lt;p&gt;相似度高的节点会在embedding后有更短的欧氏距离&lt;/p&gt;
&lt;p&gt;一阶和二阶直接拼接为节点的向量&lt;/p&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="Graph" scheme="http://example.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>网络挖掘基础</title>
    <link href="http://example.com/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-08T11:56:36.000Z</published>
    <updated>2022-10-09T08:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的性质"><a href="#图的性质" class="headerlink" title="图的性质"></a>图的性质</h1><h2 id="度中心性"><a href="#度中心性" class="headerlink" title="度中心性"></a>度中心性</h2><p>$$<br>D_i=\frac{N_i}{n-1}<br>$$</p><p>$D_i$: i 结点的度中心性</p><p>$N_i$: i 结点的度</p><p>n: 结点数量</p><h2 id="特征向量中心性"><a href="#特征向量中心性" class="headerlink" title="特征向量中心性"></a>特征向量中心性</h2><p>邻接矩阵的最大特征值对应的<strong>特征向量</strong>，给出了每个节点重要程度的度量</p><h2 id="中介中心性"><a href="#中介中心性" class="headerlink" title="中介中心性"></a>中介中心性</h2><p>$$<br>Betweenness=\frac{经过该节点的最短路径数目}{(n-2)(n-1)}<br>$$</p><p>如果两节点出现两条最短路径，经过目标节点的路径权值减半。</p><h2 id="连接中心性"><a href="#连接中心性" class="headerlink" title="连接中心性"></a>连接中心性</h2><p>$$<br>Closeness=\frac{n-1}{节点到所有其他节点最短路径长度之和}<br>$$</p><h2 id="clustering-coefficient-x2F-集聚系数-簇系数"><a href="#clustering-coefficient-x2F-集聚系数-簇系数" class="headerlink" title="clustering coefficient/集聚系数(簇系数)"></a>clustering coefficient/集聚系数(簇系数)</h2><span id="more"></span><p>$$<br>C_i=\frac{2e_i}{k_i(k_i-1)}<br>$$</p><p>某结点的邻居结点之间的边占这些结点之间最大边数的比例</p><h2 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h2><ol><li><p>指定某个节点的PR值</p></li><li><p>计算仅由它指向的节点的PR值，迭代到收敛</p><p>公式中，$N$是总节点数，所有节点都有$1-d$的保留概率被访问，$d$是阻尼系数，根据经验取0.85，阻尼系数乘上所有指向$p_i$的节点的PR值除以那些节点的出度</p></li></ol><p>$$<br>\displaystyle{ PR(p_{i}) = \frac{1-d}{N}+d\sum <em>{p</em>{j}\in B(p_{i})}\frac{PR({p_{j}})}{L({p_{j}})} }<br>$$</p><h2 id="Hits"><a href="#Hits" class="headerlink" title="Hits"></a>Hits</h2><ol><li><p>每一个网页的权威值$\displaystyle{  auth(p) = 1  }$，枢纽值$\displaystyle{  hub(p) = 1  }$</p></li><li><p>$\displaystyle{ auth(p) = \sum_{q\in P_{t_{0}}}hub(q) }$，$\displaystyle{ hub(p) = \sum_{q\in P_{from}}auth(q) }$</p><p>权威值更新为所有指向它的节点的枢纽值求和，枢纽值更新它指向的节点的权威值求和。</p></li><li><p>分别对权威值和枢纽值归一化</p></li><li><p>重复2-3直到收敛</p></li></ol><h2 id="案例分析-Zachary空手道俱乐部"><a href="#案例分析-Zachary空手道俱乐部" class="headerlink" title="案例分析-Zachary空手道俱乐部"></a>案例分析-Zachary空手道俱乐部</h2><p><code>nx.draw(nx.Graph())</code> 需要调用pyplot</p><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220307160753170.png"></p><h2 id="度分布"><a href="#度分布" class="headerlink" title="度分布"></a>度分布</h2><pre><code class="python">degree_freq = nx.degree_histogram(G)degrees = range(len(degree_freq))plt.plot(degrees, degree_freq, 'ro-')plt.title('degree distribution of Zachary')plt.xlabel('Degree')plt.ylabel('Frequency')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308163459883.png"></p><h2 id="幂律分布-无标度网络"><a href="#幂律分布-无标度网络" class="headerlink" title="幂律分布(无标度网络)"></a>幂律分布(无标度网络)</h2><pre><code class="python">G = nx.barabasi_albert_graph(10000, 10)degree_freq = nx.degree_histogram(G)degrees = range(len(degree_freq))plt.loglog(degrees[1:], degree_freq[1:],'ro') plt.title('degree distribution &amp; power law')plt.xlabel('Degree')plt.ylabel('Frequency')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220307161721628.png"></p><h2 id="簇系数（集聚系数）"><a href="#簇系数（集聚系数）" class="headerlink" title="簇系数（集聚系数）"></a>簇系数（集聚系数）</h2><blockquote><p>clustering coefficient</p></blockquote><p>$$<br>C_i=\frac{2e_i}{k_i(k_i-1)}<br>$$</p><p>某结点的邻居结点之间的边占这些结点之间最大边数的比例</p><pre><code class="python">clustering_coefs = list(nx.clustering(G).values())degrees = [n for _, n in G.degree()]data = pd.DataFrame({'clustering_coefs': clustering_coefs,                      'degrees': degrees})g = sns.lmplot(x='degrees', y='clustering_coefs', data=data)plt.title('degree-clutering')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220307162103343.png"></p><p>阴影表示置信区间</p><h2 id="度度相关性"><a href="#度度相关性" class="headerlink" title="度度相关性"></a>度度相关性</h2><blockquote><p>节点的度和邻居节点度的平均值的关系</p></blockquote><pre><code class="python">degree1 = []degree2 = []for v in G:    degree1.append(G.degree(v))    degree2.append(np.mean([G.degree(x) for x in G.neighbors(v)]))    data = pd.DataFrame({'degree1': degree1,                      'degree2': degree2})g = sns.lmplot(x='degree1', y='degree2', data=data)plt.title('degree-degree')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220307162937610.png"></p><pre><code class="Python"># 同配性系数nx.degree_assortativity_coefficient(G)# 平均距离nx.average_shortest_path_length(G)# 距离nx.distance_measures.diameter(G)# 最大连通分量largest_cc = max(nx.connected_components(G), key=len)Gcc = DG.subgraph(largest_cc)# 有向图的强连通print(nx.is_strongly_connected(Gcc))# 有向图的出度、入读DG.out_degree()DG.in_degree()</code></pre><h1 id="经典网络模型"><a href="#经典网络模型" class="headerlink" title="经典网络模型"></a>经典网络模型</h1><h2 id="随机网络"><a href="#随机网络" class="headerlink" title="随机网络"></a>随机网络</h2><pre><code class="python">n = 43m = 130p = 130G_random = nx.gnp_random_graph(n, p)G_random = nx.gnm_random_graph(n, m)print(nx.info(G_random))fig, axes = plt.subplots(figsize=(16, 8), nrows=1, ncols=1)pos = nx.circular_layout(G_random)nx.draw(G_random, pos=pos, with_labels=True, ax=axes[0])axes[0].set_title('Random network')plt.show()# 保证网络连通的 p 值大小？def plot_random_network(n, p, ax):    G_random = nx.gnp_random_graph(n, p)    is_connected = nx.is_connected(G_random)    pos = nx.circular_layout(G_random)    nx.draw(G_random, pos=pos, ax=ax)    ax.set_title('%.4f %s' %                 (p, 'Connected' if is_connected else 'Not connected'))</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308110330811.png"></p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><pre><code class="python"># degree likedegrees = [d for v, d in G_friends.degree()]G_configuration = nx.configuration_model(degrees)</code></pre><h2 id="自我中心网络"><a href="#自我中心网络" class="headerlink" title="自我中心网络"></a>自我中心网络</h2><pre><code class="python">def plot_ego_network(G, n, ax, title):        # ndoes_ego = list(nx.ego_graph(G, n, radius=1))    # G_ego = G.subgraph(ndoes_ego)    G_ego = nx.ego_graph(G, n, radius=1)        cc = nx.clustering(G)[n]        pos=nx.fruchterman_reingold_layout(G_ego, seed=1028)    d = dict(G_ego.degree)    nx.draw(G_ego, pos=pos, node_size=[v * 100 for v in d.values()], with_labels=True, ax=ax)    ax.set_title('%s, cc=%.3f' % (title, cc))n = 19fig, axes = plt.subplots(figsize=(18, 6), nrows=1, ncols=3)plt.suptitle('Ego network of node %d' % n)plot_ego_network(G_random, n, axes[0], 'Random network')# plot_ego_network(nx.Graph(G_configuration), 19, axes[1], 'Configuration network')# plot_ego_network(G_friends, 19, axes[2], 'Friends network')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308112019045.png"></p><h2 id="小世界网络"><a href="#小世界网络" class="headerlink" title="小世界网络"></a>小世界网络</h2><pre><code class="python">fig, axes = plt.subplots(figsize=(18, 6), nrows=1, ncols=3)G_regular = nx.watts_strogatz_graph(n = 16, k = 4, p = 0.0)pos = nx.circular_layout(G_regular)nx.draw(G_regular, pos=pos, with_labels=True, ax=axes[0])axes[0].set_title('Regular network')G_sm = nx.watts_strogatz_graph(n = 16, k = 4, p = 0.3)pos = nx.circular_layout(G_sm)nx.draw(G_sm, pos=pos, with_labels=True, ax=axes[1])axes[1].set_title('Small-world network')G_random = nx.gnp_random_graph(n = 16, p = 4/16)pos = nx.circular_layout(G_random)nx.draw(G_random, pos=pos, with_labels=True, ax=axes[2])axes[2].set_title('Random network')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308112408375.png"></p><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308122754592.png"></p><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308123031740.png"></p><p>规律：换掉的边越多，聚类系数越小，越接近随机网络；平均距离越小</p><h2 id="无标度网络"><a href="#无标度网络" class="headerlink" title="无标度网络"></a>无标度网络</h2><p>学习资料</p><ul><li><a href="https://www.ellipsix.net/blog/2012/02/scale-invariance-and-the-power-law.html">无标度与幂律分布</a>  </li><li><a href="https://adamwierman.com/wp-content/uploads/2020/09/2013-SIGMETRICS-heavytails.pdf">The Fundamentals of Heavy Tails</a></li><li><a href="https://www.bilibili.com/video/BV1PJ411T7ey?from=search&amp;seid=16649474684175316499&amp;spm_id_from=333.337.0.0">mandelbrot 集合</a></li></ul><h3 id="BA模型生成无标度网络"><a href="#BA模型生成无标度网络" class="headerlink" title="BA模型生成无标度网络"></a>BA模型生成无标度网络</h3><pre><code class="python">G0 = nx.star_graph(4)nx.draw(G0, with_labels=True)i = 4# 生成一个节点i += 1color_map = ['tab:blue'] * icolor_map.append('tab:red')G1 = G0.copy()G1.add_node(i)nx.draw(G1, node_color=color_map, with_labels=True)# 按照度的大小概率连接possible_neighbors = list(G0.nodes)degrees = [G0.degree(n) for n in possible_neighbors]neighbors_to_choose = [[n] * G0.degree(n) for n in possible_neighbors]neighbors_to_choose = [i for l in neighbors_to_choose for i in l]neighbors_to_choosej = random.choices(neighbors_to_choose)[0]print('new neighbor is %d' % j)G0.add_edge(i, j)nx.draw(G0, node_color=color_map, with_labels=True)# 重复def get_SF(G):        i = len(G.nodes())        possible_neighbors = list(G.nodes)    degrees = [G.degree(n) for n in possible_neighbors]        neighbors_to_choose = [[n] * G.degree(n) for n in possible_neighbors]    neighbors_to_choose = [i for l in neighbors_to_choose for i in l]    j = random.choices(neighbors_to_choose)[0]    G.add_edge(i, j)    G = nx.star_graph(4)N = 100for i in range(N):    get_SF(G)    nx.draw(G)    </code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308165729644.png" alt="image-20220308165729644"></p><h3 id="对无标度网络的攻击"><a href="#对无标度网络的攻击" class="headerlink" title="对无标度网络的攻击"></a>对无标度网络的攻击</h3><blockquote><p>随机移除节点 vs 蓄意移除节点</p></blockquote><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308170355504.png"></p><h1 id="社团结构"><a href="#社团结构" class="headerlink" title="社团结构"></a>社团结构</h1><h2 id="手动划分"><a href="#手动划分" class="headerlink" title="手动划分"></a>手动划分</h2><pre><code class="python">G = nx.Graph()nx.add_cycle(G, [0, 1, 2])nx.add_cycle(G, [3, 4, 5])G.add_edge(2, 3)pos = nx.fruchterman_reingold_layout(G)nx.draw(G, with_labels=True, pos=pos)partition1 = [    {0, 1},    {2, 3},    {4, 5},]partition_map1 = {}for idx, cluster_nodes in enumerate(partition1):    for node in cluster_nodes:        partition_map1[node] = idx        </code></pre><h2 id="随机划分"><a href="#随机划分" class="headerlink" title="随机划分"></a>随机划分</h2><pre><code class="python">random_nodes = random.sample(K.nodes, 17)random_partition = [set(random_nodes),set(K.nodes) - set(random_nodes)] # 差集</code></pre><h2 id="模块度-Modularity"><a href="#模块度-Modularity" class="headerlink" title="模块度 Modularity"></a>模块度 Modularity</h2><p>一个好的社团发掘算法：社团内部连边多，社团之间连边少。</p><p>For weighted undirected networks, as described in the text, we have<br>$$<br>\begin{equation}<br>    Q_w=\frac{1}{W}\sum_C \left(W_C-\frac{s_C^2}{4W}\right),<br>    \label{eq:wmodul}<br>\end{equation}<br>$$</p><p>where </p><ul><li>$W$ is the total weight of the links of the network,</li><li>$W_C$ the total weight of the internal links of cluster $C$, and</li><li>$s_C$ the total strength of the nodes of $C$.</li></ul><p>值得注意的是：</p><ul><li>最优的划分， 0 &lt; Q &lt; 1；</li><li>若把所有节点当成同一个社团，则 Q = 0；</li><li>若把每一个节点当成不同的社团，则 Q &lt; 0；</li></ul><pre><code class="python">import matplotlib.pyplot as pltfig = plt.figure(figsize=(12, 4))plt.subplot(1, 2, 1)nx.draw(G, with_labels=True, node_color=node_colors1, pos=pos)plt.title('partition1')plt.subplot(1, 2, 2)nx.draw(G, with_labels=True, node_color=node_colors2, pos=pos)plt.title('partition2')plt.show()</code></pre><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308180939432.png"></p><h3 id="贪婪模块度划分"><a href="#贪婪模块度划分" class="headerlink" title="贪婪模块度划分"></a>贪婪模块度划分</h3><pre><code class="python">from networkx.algorithms.community import greedy_modularity_communitiesoptimal_partition = greedy_modularity_communities(K)nx.community.quality.modularity(K, optimal_partition)</code></pre><h3 id="Girvan-Newman划分算法"><a href="#Girvan-Newman划分算法" class="headerlink" title="Girvan-Newman划分算法"></a>Girvan-Newman划分算法</h3><p>不断的删除网络中边介数（Betweenness）最大的边，直到网络中每个节点都是一个社团为止。</p><ol><li>计算每一条边的边介数； </li><li>删除边介数最大的边； </li><li>重新计算网络中剩下的边的边阶数；</li><li>重复(3)和(4)步骤，直到网络中的任一顶点作为一个社区为止。</li></ol><p><img src="/2022/03/08/%E7%BD%91%E7%BB%9C%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/image-20220308182129101.png"></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><a href="https://www.bilibili.com/video/BV1Az4y1Q7v5?from=search&amp;seid=14361555497668642316&amp;spm_id_from=333.337.0.0">Gephi 中文教程</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图的性质&quot;&gt;&lt;a href=&quot;#图的性质&quot; class=&quot;headerlink&quot; title=&quot;图的性质&quot;&gt;&lt;/a&gt;图的性质&lt;/h1&gt;&lt;h2 id=&quot;度中心性&quot;&gt;&lt;a href=&quot;#度中心性&quot; class=&quot;headerlink&quot; title=&quot;度中心性&quot;&gt;&lt;/a&gt;度中心性&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;D_i=\frac{N_i}{n-1}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$D_i$: i 结点的度中心性&lt;/p&gt;
&lt;p&gt;$N_i$: i 结点的度&lt;/p&gt;
&lt;p&gt;n: 结点数量&lt;/p&gt;
&lt;h2 id=&quot;特征向量中心性&quot;&gt;&lt;a href=&quot;#特征向量中心性&quot; class=&quot;headerlink&quot; title=&quot;特征向量中心性&quot;&gt;&lt;/a&gt;特征向量中心性&lt;/h2&gt;&lt;p&gt;邻接矩阵的最大特征值对应的&lt;strong&gt;特征向量&lt;/strong&gt;，给出了每个节点重要程度的度量&lt;/p&gt;
&lt;h2 id=&quot;中介中心性&quot;&gt;&lt;a href=&quot;#中介中心性&quot; class=&quot;headerlink&quot; title=&quot;中介中心性&quot;&gt;&lt;/a&gt;中介中心性&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;Betweenness=\frac{经过该节点的最短路径数目}{(n-2)(n-1)}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;如果两节点出现两条最短路径，经过目标节点的路径权值减半。&lt;/p&gt;
&lt;h2 id=&quot;连接中心性&quot;&gt;&lt;a href=&quot;#连接中心性&quot; class=&quot;headerlink&quot; title=&quot;连接中心性&quot;&gt;&lt;/a&gt;连接中心性&lt;/h2&gt;&lt;p&gt;$$&lt;br&gt;Closeness=\frac{n-1}{节点到所有其他节点最短路径长度之和}&lt;br&gt;$$&lt;/p&gt;
&lt;h2 id=&quot;clustering-coefficient-x2F-集聚系数-簇系数&quot;&gt;&lt;a href=&quot;#clustering-coefficient-x2F-集聚系数-簇系数&quot; class=&quot;headerlink&quot; title=&quot;clustering coefficient/集聚系数(簇系数)&quot;&gt;&lt;/a&gt;clustering coefficient/集聚系数(簇系数)&lt;/h2&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="Graph" scheme="http://example.com/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>智能合约漏洞综述</title>
    <link href="http://example.com/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/"/>
    <id>http://example.com/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-12-13T04:02:57.000Z</published>
    <updated>2021-12-13T06:02:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>404的是本地pdf，自己搜论文</p></blockquote><h1 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h1><p><a href="35-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf">35-智能合约安全漏洞研究综述</a><br>#张超-清华<br><a href="%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf">智能合约安全漏洞检测技术研究综述</a><br>#钱鹏-浙工商<br><a href="%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E7%BB%BC%E8%BF%B0_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.pdf">智能合约安全综述_漏洞分析</a></p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><ul><li>股权众筹</li><li>游戏</li><li>保险</li><li>供应链</li><li>物联网</li></ul><span id="more"></span><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><table><thead><tr><th>安全事件</th><th>安全漏洞</th><th>时间</th><th>危害</th></tr></thead><tbody><tr><td>The DAO</td><td>重入</td><td>2016.6</td><td>$5000w hard-fork</td></tr><tr><td>Parity钱包被盗+冻结</td><td>代码注入+权限不当</td><td>2017.7</td><td>$3000w 冻结</td></tr><tr><td>BEC/SMT</td><td>整数溢出</td><td>2018.4</td><td>攻击者大量抛售后市值归零</td></tr><tr><td>KotET合约拒绝服务</td><td>拒绝服务</td><td>2016.2</td><td>攻击者获得永久王座</td></tr></tbody></table><h3 id="第一次parity"><a href="#第一次parity" class="headerlink" title="第一次parity"></a>第一次parity</h3><pre><code class="solidity">contract WalletLibrary {     address owner;     // called by constructor     function initWallet(address _owner) {         owner = _owner;         // ... more setup ...     }     function changeOwner(address _new_owner) external {         if (msg.sender == owner) {             owner = _new_owner;         }     }     function () payable {         // ... receive money, log events, ...     }     function withdraw(uint amount) external returns (bool success) {         if (msg.sender == owner) {             return owner.send(amount);         } else {             return false;         }     }}</code></pre><pre><code class="solidity">contract Wallet {    address _walletLibrary;    address owner;    function Wallet(address _owner) {        // replace the following line with “_walletLibrary = new WalletLibrary();”        // if you want to try to exploit this contract in Remix.        _walletLibrary = &lt;address of pre-deployed WalletLibrary&gt;;        _walletLibrary.delegatecall(bytes4(sha3("initWallet(address)")), _owner);    }    function withdraw(uint amount) returns (bool success) {        return _walletLibrary.delegatecall(bytes4(sha3("withdraw(uint)")), amount);    }    // fallback function gets called if no other function matches call    function () payable {        _walletLibrary.delegatecall(msg.data);    }}</code></pre><p>wallet 合约将所有行为交给walletLibrary代理执行。首先同名构造函数 <code>Wallet(address _owner)</code> 在合约创建时执行，钱包拥有者为合约创建者。fallback函数将递交所有的数据给代理库，这里埋下了隐患。当攻击者调用<code>Wallet.initWallet(attacker)</code>时，不匹配Wallet 中的任何显式函数，所以进入fallback函数，<code>initWallet(attacker)</code>将被转发给代理。<code>initWallet(attacker)</code>命中 walletLibrary 中的函数跳转表，于是在wallet 的上下文中再次执行<code>initWallet()</code>从而使自己成为了钱包拥有者。</p><blockquote><p>msg.sender: 交易发起者</p><p>msg.value: 转账金额，大于0将触发收款方的fallback函数</p><p>msg.data: 调用函数，也可以随便写，当不命中跳转表时会调用fallback</p></blockquote><p><a href="https://hackingdistributed.com/2017/07/22/deep-dive-parity-bug/">An In-Depth Look at the Parity Multisig Bug</a></p><blockquote><p>At the EVM level, a contract is just a single program that takes a variable-length binary blob of data as input and produces a variable-length binary blob of data as its output. A transaction in EVM provides an address and some data. If the address holds code, this data is used in a “<a href="https://en.wikipedia.org/wiki/Branch_table">jump table</a>” like structure in the beginning of the contract’s code, with some of the data (the “function selector”) indexing jumps to different parts of contract code using the standard encodings described in the <a href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI">Ethereum Contract ABI specification</a>. Above, the function selector for calling a function called initWallet that takes an address as its argument is the mysterious looking bytes4(sha3(“initWallet(address)”)).</p></blockquote><h3 id="第二次parity"><a href="#第二次parity" class="headerlink" title="第二次parity"></a>第二次parity</h3><p>Parity 钱包提供了多签钱包的库合约。当库合约的函数被 delegatecall 调用时，它是运行在调用方（即：用户多签合约）的上下文里，像 m_numOwners 这样的变量都来自于用户多签合约的上下文。另外，为了能被用户合约调用，这些库合约的初始化函数都是 public 的。</p><p>库合约本质上也不过是另外一个智能合约，这次攻击调用使用的是库合约本身的上下文。这源于大家忽视了库本身的独立性，其中也包括Parity的维护者。他们应该在库合约部署后立刻调用一次<code>initWallet()</code>以<strong>锁定</strong>所有权，结果等了一百多天，被黑客抢先。</p><p>攻击流程:</p><ol><li>攻击者直接调用库合约的<code>initWallet()</code>把自己设置为库合约的 owner。</li><li>攻击者调用<code>kill()</code>函数，把库合约删除，所有依赖于这个库的钱包被冻结了。</li></ol><blockquote><p>这一攻击在上述的第一次parity中不会发生，因为没写kill函数！</p></blockquote><p>解决办法：构造函数获得库合约所有权后，把库合约的m_numOwners变量置1</p><h3 id="REX"><a href="#REX" class="headerlink" title="REX"></a>REX</h3><ul><li><a href="https://cointelegraph.com/news/hacker-spends-1k-to-win-over-110k-in-eos-betting-game-using-rex">REX</a></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>开发</li><li>编译<ul><li>高级语言编写的合约源代码都将被编译为统一规范的<strong>字节码</strong>(bytecode)才能在EVM上运行</li><li>同时，合约还会生成相应的合约调用接口(Application Binary Interface, ABI), 该接口定义了合约所有可以被调用的<strong>外部函数</strong>及其<strong>参数列表</strong>。</li></ul></li><li>部署<br>由一笔合约部署交易完成：<ul><li>合约的data字段将被设置为合约部署字节码，交易的接收方被设置0</li><li>矿工在交易打包时将根据合约部署者的地址和交易次数(nonce)来生成一个新的地址，并将合约的字节码部署到该地址</li><li>将执行构造函数，包括合约变量初始化和同名函数</li></ul></li><li>调用<ul><li>交易调用(transaction call): 由普通地址发起一笔合约调用</li><li>消息调用(message call): 由某个合约发起的对另一个合约中函数的调用</li></ul></li><li>销毁<br>在合约编写时加入销毁功能的合约才能在满足设定条件后销毁。销毁只是意味着不能调用，其storage和的代码都可以查看</li></ol><h2 id="程序特性"><a href="#程序特性" class="headerlink" title="程序特性"></a>程序特性</h2><h3 id="gas机制"><a href="#gas机制" class="headerlink" title="gas机制"></a>gas机制</h3><p>以太坊设计了 Gas 机制来为合约的执行计算费用。每一个以太坊字节码指令都<strong>根据其运算的复杂程度</strong>被标记了对应的需要消耗的 Gas 花费。合约调用方在发起一次合约调用时, 需要指定本次合约程序执行最高能花费的 Gas 数量, 并为这个最大数量先行付费。数量不足即回滚且不退费，数量充足则退剩下的费用。 #gas</p><h3 id="异常传递机制"><a href="#异常传递机制" class="headerlink" title="异常传递机制"></a>异常传递机制</h3><p>#exception</p><ul><li><strong>内部函数调用：</strong> 对于本合约或者父合约的内部函数的调用，只需要在以太坊虚拟机执行时进行指令跳转。</li><li><strong>外部函数调用：</strong> 对于指定地址的外部合约函数的调用，需要使用 CALL 指令向外部合约发送消息，这种调用也称为<strong>低级别的调用</strong>。对于所有的低级别调用来说, 如果被调用函数执行过程中出错而抛出异常，则异常并不会被沿着函数调用栈进行传递, 而是仅使用布尔类型的返回值来表示函数调用是否正常完成。 #low-level-call<ul><li><strong>委托调用：</strong> 外部函数调用的一种，本质上是对当前合约函数注入外部代码 #delegate</li></ul></li></ul><h3 id="合约代码无法修改"><a href="#合约代码无法修改" class="headerlink" title="合约代码无法修改"></a>合约代码无法修改</h3><p>一旦部署，无法修改。保证了唯一性，但是也不能修漏洞了。</p><h3 id="全局状态与调用序列"><a href="#全局状态与调用序列" class="headerlink" title="全局状态与调用序列"></a>全局状态与调用序列</h3><p>每个合约都有一个长期的 Storage 存储区域，为合约存储可跨函数使用的全局变量状态。由于合约的<strong>多入口调用方式</strong>，因此在不同函数内部的变量关系、约束结果会随着全局变量进行跨函数的传递，最直接的体现特征就是特定功能或者漏洞的触发需要<strong>多笔交易组成的调用序列</strong>来完成。</p><h2 id="按来源归类漏洞"><a href="#按来源归类漏洞" class="headerlink" title="按来源归类漏洞"></a>按来源归类漏洞</h2><p><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211211201858358.png"></p><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol><li>变量覆盖<br>在受影响的版本的solidity语言中，其声明的数组或者结构体类型变量会被编译器误用为 Storage 类型的变量。从而, 对这些变量的操作将导致对智能合约 Storage 存储区的非法覆盖。</li><li>整数溢出</li><li>未检验返回值，针对 #low-level-call </li><li>任意地址写入，针对storage的键值对</li><li>拒绝服务</li><li>资产冻结</li><li>未初始化变量</li><li>影子变量<ol><li>子合约中声明了与父合约中相同的storage变量</li><li>全局storage变量和函数内部的局部变量重名</li></ol></li><li>权限控制</li></ol><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>三类存储空间：Stack, Memory, Storage </p><table><thead><tr><th>name</th><th>grain</th><th>description</th></tr></thead><tbody><tr><td>stack</td><td>32字节</td><td>作为程序运行时的必要组件, 用于保存程序运行时的各种临时数据</td></tr><tr><td>memory</td><td>单字节</td><td>保存数组、字符串等较大的临时数据</td></tr><tr><td>storage</td><td>32字节</td><td>消耗大量gas，作为区块链状态的一部分永久存储</td></tr></tbody></table><p><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211211193109887.png"></p><h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><p>有典型重入漏洞的代码如下所示：</p><pre><code class="solidity">    contract ERCToken{    ...    function withdraw(uint amount) public returns    (bool){        if (credit[msg.sender]&gt;= amount) {            msg.sender.call.value(amount)();            credit[msg.sender]-=amount;            emit Withdraw(msg.sender, amount);            return true;            }        return false;        }    }</code></pre><p>如果收到转账的地址是一个<strong>合约地址</strong>，便会<strong>触发收款方的 fallback 函数</strong>，默认fallback函数为<code>function() external payable{}</code>。该机制本意是让任何一个合约不用写代码也能获得收款的能力，但它可能被恶意的攻击者用于发起<strong>重入攻击</strong>。 Attack 是一个攻击合约，其代码如下所示:</p><pre><code class="solidity">    contract Attack{    ...    function hack() public {        erctoken.withdraw(1);        }    function() public payable { //fallback 函数        erctoken.withdraw(1);        }    }</code></pre><p>攻击者只需要通过 hack 函数调用受害合约的 withdraw 函 数，受害合约 withdraw 函数中<code>msg.sender.call.value(amount)()</code>语句执行时，会触发攻击合约中的 fallback 函数，整个攻击过程如图所示：<br><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211211221424451.png"><br>解决办法：</p><ol><li>先<code>credit[msg.sender]-=amount</code>再转账</li><li>用<code>transfer()</code>限制gas</li></ol><h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>委托调用所使用的 DELEGATECALL 字节码, 允许合约在自己的上下文环境中执行一段其他合约的代码片段。 #delegate </p><h4 id="短地址攻击"><a href="#短地址攻击" class="headerlink" title="短地址攻击"></a>短地址攻击</h4><p>是指攻击者通过构造末尾为零的地址进行合约调用, 并在调用参数中故意将地址末尾的零舍去, 从而利用虚拟机对于数据的自动补全机制来将<strong>第二个参数进行移位放大</strong>。而第二个参数往往是转账金额。</p><h4 id="不一致性攻击"><a href="#不一致性攻击" class="headerlink" title="不一致性攻击"></a>不一致性攻击</h4><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><h4 id="时间戳依赖"><a href="#时间戳依赖" class="headerlink" title="时间戳依赖"></a>时间戳依赖</h4><p>区块时间戳是指当前的合约调用交易所属的区块被打包的时间戳。区块时间戳是可以被矿工在一 定的取值范围内操纵的，大约能有900秒的范围波动。</p><h4 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h4><p>仅仅通过交易顺序来作为决策条件是有问题的。例如, 某个悬赏合约承诺给第一个提交答案的账户奖励。在第一个人提交答案，但还没被打包时，攻击者可以在交易池中找到这个答案并通过<strong>提高汽油费</strong>来让自己“抄”的答案优先被打包。</p><h4 id="随机性不足"><a href="#随机性不足" class="headerlink" title="随机性不足"></a>随机性不足</h4><p>由于对于攻击合约和受害合约的调用都来自于攻击者发起的同一笔交易, 自然处在同一个区块中, 因此攻击合约中可以读取到和受害合约中使用的全部区块变量, 从而预测受害合约中的随机数。</p><h2 id="漏洞挖掘方法"><a href="#漏洞挖掘方法" class="headerlink" title="漏洞挖掘方法"></a>漏洞挖掘方法</h2><p><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211212140200083.png"></p><h3 id="模糊测试-Fuzz-testing"><a href="#模糊测试-Fuzz-testing" class="headerlink" title="模糊测试 Fuzz testing"></a>模糊测试 Fuzz testing</h3><ul><li><strong>黑盒模糊测试</strong>不对程序内部结构进行分析, 而是通过生成随机输入触发程序的缺陷。</li><li><strong>白盒模糊测试</strong>则利用符号执行等程序分析技术对程序结构进行分析, 以提高覆盖率和漏洞挖掘能力。</li><li><strong>灰盒模糊测试</strong>不对程序进行分析但会根据程序反馈调整输入。<br>针对生成调用序列的优化：</li></ul><p><a href="Harvey.pdf">Harvey</a></p><blockquote><p>Harvey: 通过对在智能合约程序中条件判断语句之前进行插桩的方式, 来测量合约的每一次输入是否有利于产生新的路径。此外, Harvey 还尝试通过不同函数间对全局变量的读写依赖关系进行来生成简单的调用序列, 以提高序列对程序覆盖率的影响。</p></blockquote><p><a href="ILF.pdf">ILF</a></p><blockquote><p>ILF: 其首先选取部分的智能合约程序, 并使用符号执行引擎工具对这写合约进行多次的符号执行, 以产生出覆盖率足够高的调用序列。接下来, ILF 使用神经网络对这些调用序列特征进行训练, 并生成可以模仿该序列生成规则的模型以指导模糊测试。 </p><h3 id="符号执行-Symbolic-execution"><a href="#符号执行-Symbolic-execution" class="headerlink" title="符号执行  Symbolic execution"></a>符号执行  Symbolic execution</h3><p>主要思想是把程序执行过程中不确定的输入转换为<strong>符号值</strong>，以推动程序执行与分析。<br>智能合约与传统程序的差异主要在于合约中<strong>全局变量</strong>的取值是不确定的，因此智能合约的全局变量也需要被处理为符号值。<br><a href="https://github.com/ConsenSys/mythril">Mythril</a>: 多次符号执行增加全局变量的真实性<br><a href="Manticore.pdf">Manticore</a>: 变量值具体化+多合约分析<br><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211213101229185.png"></p><h3 id="形式化验证-Formal-verification"><a href="#形式化验证-Formal-verification" class="headerlink" title="形式化验证  Formal verification"></a>形式化验证  Formal verification</h3><p>形式化验证技术通常使用形式化的描述语言来描述一个系统的属性和特点, 为其构造出形式化规范, 再运用严格的数学逻辑证明来对其实际的运行时行为进行推理。<br><a href="sp20-verx.pdf">sp20-verx</a>: 延迟谓词抽象技术将交易执行期间的符号执行信息与交易之间的抽象信息相结合</p></blockquote><h3 id="静态程序分析"><a href="#静态程序分析" class="headerlink" title="静态程序分析"></a>静态程序分析</h3><p>SASC、SmartCheck、Slither</p><h3 id="污点分析"><a href="#污点分析" class="headerlink" title="污点分析"></a>污点分析</h3><p>通过影子栈等方式实现更加精确的数据流分析<br><img src="/2021/12/13/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0/image-20211212211555358.png"></p><h2 id="攻防"><a href="#攻防" class="headerlink" title="攻防"></a>攻防</h2><h3 id="自动化漏洞利用（自动攻击）"><a href="#自动化漏洞利用（自动攻击）" class="headerlink" title="自动化漏洞利用（自动攻击）"></a>自动化漏洞利用（自动攻击）</h3><p><a href="teEther.pdf">teEther</a></p><h3 id="攻击阻断"><a href="#攻击阻断" class="headerlink" title="攻击阻断"></a>攻击阻断</h3><p>Sereum、EVM*提出了有效的实时攻击检测方案, ÆGIS则进一步提出了如何改进区块链中的<strong>共识算法</strong>以让全网节点对恶意交易的阻断达成共识, 但是其算法设计较为粗糙, 难以被真实应用</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>Libra公司开发了面向资产的中间语言Move, 通过<strong>静态类型绑定</strong>、<strong>强制类型检查</strong>、<strong>不支持无限循环递归</strong>等方式增加安全性。将不同的高级语言编译为统一的中间语言，来提供统一的安全保障。</p><ol><li>构建统一且规范的智能合约漏洞数据集</li><li>构建基于深度学习的动静态分析综合模型</li><li>构建统一的漏洞检测工具性能评估体系</li></ol><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p>#idea</p><ol><li>十五种漏洞中，大多通过编译器就能检测出。</li><li>有安全模板和库已经大量应用</li><li>针对新功能、罕用功能的新漏洞</li><li>公共库的漏洞</li></ol><h2 id="深度学习的应用"><a href="#深度学习的应用" class="headerlink" title="深度学习的应用"></a>深度学习的应用</h2><ol><li>模糊测试的输入序列</li><li>静态分析的构图+GNN</li><li>符号分析的强化学习方法</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol><li>数据集手工分析，提取特征：storage、函数调用、逻辑跳转</li><li>复现和修改构图方式，比如基于符号分析构图</li><li>看基于深度学习方法挖掘漏洞的论文</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;404的是本地pdf，自己搜论文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;paper&quot;&gt;&lt;a href=&quot;#paper&quot; class=&quot;headerlink&quot; title=&quot;paper&quot;&gt;&lt;/a&gt;paper&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;35-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf&quot;&gt;35-智能合约安全漏洞研究综述&lt;/a&gt;&lt;br&gt;#张超-清华&lt;br&gt;&lt;a href=&quot;%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0.pdf&quot;&gt;智能合约安全漏洞检测技术研究综述&lt;/a&gt;&lt;br&gt;#钱鹏-浙工商&lt;br&gt;&lt;a href=&quot;%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E7%BB%BC%E8%BF%B0_%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.pdf&quot;&gt;智能合约安全综述_漏洞分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用领域&quot;&gt;&lt;a href=&quot;#应用领域&quot; class=&quot;headerlink&quot; title=&quot;应用领域&quot;&gt;&lt;/a&gt;应用领域&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;股权众筹&lt;/li&gt;
&lt;li&gt;游戏&lt;/li&gt;
&lt;li&gt;保险&lt;/li&gt;
&lt;li&gt;供应链&lt;/li&gt;
&lt;li&gt;物联网&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="Blockchain" scheme="http://example.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>北大肖臻区块链技术与应用</title>
    <link href="http://example.com/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-12-04T07:34:45.000Z</published>
    <updated>2021-12-11T03:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记得比较琐碎，以太坊部分待补充完整</p></blockquote><h1 id="BTC-密码学原理"><a href="#BTC-密码学原理" class="headerlink" title="BTC-密码学原理"></a>BTC-密码学原理</h1><p>比特币最小单位satoshi</p><p>crypto-currency加密货币</p><p>cryptographic hash function密码哈希函数</p><h2 id="哈希函数的性质"><a href="#哈希函数的性质" class="headerlink" title="哈希函数的性质"></a>哈希函数的性质</h2><ol><li><strong>collision resistance</strong>冲突阻碍，指会发生哈希冲突的两个输入难以用某个高效算法找到</li></ol><blockquote><p>由实践经验得出某些哈希函数无法人为制造哈希碰撞，这一点无法在数学上证明</p><p>另一些算法，如MD5 已经被破解</p></blockquote><p>​brute-force暴力破解，指用穷举法破解</p><p>​message digest信息摘要/指纹，指利用冲突阻碍原理，信息被篡改后哈希值不改变的情况难以找到</p><span id="more"></span><ol start="2"><li><strong>hiding</strong>隐匿性</li></ol><p>​H(x)难以反推x，只能用暴力破解</p><p>​<strong>条件：</strong>x的样本空间足够大且分布均匀</p><ol start="3"><li><strong>puzzle friendly</strong></li></ol><p>$$<br>H(block header) &lt;= target<br>$$<br>$$<br>difficulty=\frac{挖矿难度=1,时对应的,target}{当前,target}<br>$$<br>$$<br>target=target<em>\frac{挖出最近,2016,个块的实际时间}{2016</em>10min}<br>$$</p><p>​target 设定目标，前面都是0，nBits</p><p>​新的target由上面公式算出，但必须处于在上一个的1/4～4倍之间，超过这个范围按边界值</p><p>​这一性质说明，完成这个目标，一定是进行了大量的穷举，即 <strong>proof of work工作量证明</strong></p><p>​difficult to solve, but  easy to verify </p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>对于股票预测的提前公布会影响股价，所以要提前一天放到封好的信封里</p><p>预测者仅仅提前公布自己的哈希值，第二天收盘时，再公布自己的预测文件</p><ul><li>预测者无法修改这个文件</li><li>别人无法提前反推这个文件</li></ul><p><strong>问题：</strong>股票的输入空间不足，这会导致隐匿性丧失；但预测者的修改还是很难实现</p><p><strong>解决：</strong>通过拼接随机数(nonce)扩大输入空间</p><h2 id="比特币用的哈希算法"><a href="#比特币用的哈希算法" class="headerlink" title="比特币用的哈希算法"></a>比特币用的哈希算法</h2><p>SHA-256</p><p>Secure Hash Algorithm</p><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>如何开帐户？创立公钥私钥对</p><p>asymmetric encryption algorithm 非对称加密</p><p>加密用公钥，解密用对应的私钥</p><p>签名用私钥，验证用公钥 </p><h1 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC-数据结构"></a>BTC-数据结构</h1><h2 id="hash-pointers"><a href="#hash-pointers" class="headerlink" title="hash pointers"></a>hash pointers</h2><p><strong>哈希指针</strong>：前一个区块的位置+H(前一个区块包含其哈希指针的所有数据)结构体</p><p>genesis block创世区块</p><p>most recent block最近区块</p><p>tamper-evident log  篡改事件日志，指中间任意一个哈希修改都会导致之后所有区块哈希值的改变</p><h2 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h2><p>默克尔树</p><p>由每个区块包含的交易构建</p><p>merkle proof</p><h2 id="block-header-block-body"><a href="#block-header-block-body" class="headerlink" title="block header + block body"></a>block header + block body</h2><p>block header：</p><ul><li><p>version</p></li><li><p>hash of previous block header 只取块头哈希</p></li><li><p>merkle root hash 存储了和当前区块交易所有相关区块的根哈希值</p></li><li><p>target</p></li><li><p>nonce</p></li></ul><p>blcok body：</p><ul><li>交易列表</li></ul><p><strong>问题</strong>：只保存了header的轻节点如何验证一笔交易是否写入了区块链中？</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125141800039.png" alt="image-20211125141800039"></p><blockquote><p>只要验证当前交易所在的分支，就可以证明交易tx的存在，这称之为proof of membership/inclusion</p><p>那么如何验证某个交易不存在呢？这需要获取整棵树挨个计算。更好的方案是用叶子结点按哈希值排好序。</p></blockquote><h2 id="全节点和轻节点"><a href="#全节点和轻节点" class="headerlink" title="全节点和轻节点"></a>全节点和轻节点</h2><p><strong>fully validationg node</strong></p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211126112329965.png"></p><p><strong>light node</strong></p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211126112314323.png"></p><h1 id="BTC-协议"><a href="#BTC-协议" class="headerlink" title="BTC-协议"></a>BTC-协议</h1><p>double spending attack: 一张数字货币很容易通过复制操作变两张</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125193750904.png"></p><p><strong>问题</strong>：B的同伙B’知道A的公钥/地址，为什么不能冒充A</p><ol><li>一方面，B’如果用自己的公钥作为输入，并声明这是A的公钥。这一公钥和其来源，即A收款的输出，即A的地址，对不上</li><li>另一方面，B’如果用A的公钥作为输入，别人会用这个去解密。但你不知道A的私钥，不能用A的私钥签名，别人用A的公钥解密的时候出错</li></ol><blockquote><p>交易的输入：币的来源交易的输出+付款人的公钥</p><p>交易的输出：收款人的地址</p></blockquote><h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><blockquote><p>membership机制：筛选优质会员参与 比如hyperledger 联盟链</p></blockquote><blockquote><p>如果仅仅采用投票机制，sybil attack 机器产生大量账户投票</p></blockquote><ol><li>BTC的共识：算出nonce的节点获得记账权</li></ol><p>​获得记账权的好处： </p><ul><li>出块奖励 block reward  挖出新区块的将获得铸币</li><li>帮别人记账的交易费 transaction fee</li></ul><p>​mining miner</p><ol start="2"><li>longest valid chain</li></ol><h1 id="BTC-实现"><a href="#BTC-实现" class="headerlink" title="BTC-实现"></a>BTC-实现</h1><p>UTXO: unspent TX output</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125211205209.png"></p><p>给定任何一个区块，计算当前所有的UXTO金额之和，等同于自创世区块到给定区块的挖矿奖励之和。</p><p>在钱包程序中，钱包管理的是一组私钥，对应的是一组公钥和地址。钱包程序必须从创世区块开始扫描每一笔交易，如果：</p><ol><li>遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；</li><li>遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。</li></ol><p>UXTO是存储在本地的，其正确性由遍历整个区块链验证</p><p><strong>transaction-based ledger</strong></p><p>irrevocable ledger不可篡改交易</p><h2 id="zero-confirmation-amp-six-confirmation"><a href="#zero-confirmation-amp-six-confirmation" class="headerlink" title="zero-confirmation &amp; six-confirmation"></a>zero-confirmation &amp; six-confirmation</h2><p>需要回滚某笔交易，在该比交易所在区块的前一个区块开始分叉，只要比原链更长即可</p><p>所以电商需要等待六个区块，使得分叉攻击几乎不可能</p><p>零确认指的是还未挖出新区块，电商自行验证签名和UXTO后确认收款：</p><ul><li>比特币网络中诚实的节点只会接收最早的交易</li><li>发货还需要时间，发现用户回滚交易就不发货。这时候这笔交易后的区块已经很多了</li></ul><h2 id="selfish-mining"><a href="#selfish-mining" class="headerlink" title="selfish mining"></a>selfish mining</h2><p>挖出区块但不立刻发布有什么好处？</p><p>如果比其他人快一步，别人的算力都浪费在竞争前一个区块上</p><p>但如果运气不好被别人赶上了，自己的算力都浪费了</p><h1 id="BTC-网络"><a href="#BTC-网络" class="headerlink" title="BTC-网络"></a>BTC-网络</h1><p>appication layer: BitCoin Block chain</p><p>network layer: P2P Overlay Network</p><p>simple, robust, but not efficient</p><p>flooding的方式消息传播 best effort</p><h1 id="BTC-挖矿"><a href="#BTC-挖矿" class="headerlink" title="BTC-挖矿"></a>BTC-挖矿</h1><p>调整nonce 4bytes输入空间不够，可能全部尝试了还是到不了target</p><p>所以实际计算还有coinbase交易的coinbase field可以调整，这将影响header里的merkle tree root</p><p><strong>问题</strong>：矿主是如何避免矿工挖到区块自行发布，同时又获得almost valid block的奖励？</p><p><strong>解决</strong>：coinbase的收款地址必须是矿主</p><ul><li><p>这保证了挖出来的奖励只能给矿主。如果填自己的那就没人一起挖，就和矿池没关系了。</p></li><li><p>矿工提交的almost valid block一定是填了矿主的地址。如果他填了自己的地址，也就是不按照矿主发给他的挖，那矿主那边验证不通过，他就拿不到部分奖励。</p></li></ul><h2 id="矿池的优劣"><a href="#矿池的优劣" class="headerlink" title="矿池的优劣"></a>矿池的优劣</h2><p>好处：能让矿工的收入稳定</p><p>坏处：会导致51%攻击，比如回滚和联合抵制（boycott）</p><h1 id="BTC-分叉"><a href="#BTC-分叉" class="headerlink" title="BTC-分叉"></a>BTC-分叉</h1><p>state fork: 随时会产生的</p><ul><li>forking attack or deliberate fork</li></ul><p>protocol fork: 软件/协议升级产生的</p><ul><li>hard fork:新版本认可老版本<ul><li>旧节点不更新软件，那么他将永远无法认可新版本的区块，即使含有新版本的链更长。社区会产生分裂，从而产生两种币</li><li>更新软件的新节点仍然认可老版本的区块，按照最长链原则</li><li>防范重放攻击，带chain ID</li></ul></li><li>soft fork： 新版本不兼容老版本<ul><li>新版本节点掌握大多数算力，老版本节点被迫更新</li></ul></li></ul><h1 id="BTC-匿名性-anonymity"><a href="#BTC-匿名性-anonymity" class="headerlink" title="BTC-匿名性 anonymity"></a>BTC-匿名性 anonymity</h1><p>pseudonymity 别名</p><p><strong>问题</strong>：不同的地址如何关联在一起？</p><ul><li><p>一笔交易如果你的某个地址余额不足，可以有多个输入，多个输入是同一个人</p></li><li><p>一笔交易如果有多个输出，一个是商家收款地址，另一个多出来的找零给自己的新地址</p></li></ul><p><strong>解决</strong>：零币和零钞</p><p><strong>问题</strong>：什么情况能对应现实中的某人？</p><ul><li>大额兑现法币，或者用法币买入</li><li>比特币线下支付，消费记录人人可查</li></ul><p>silk road 黑店</p><h2 id="提高匿名性"><a href="#提高匿名性" class="headerlink" title="提高匿名性"></a>提高匿名性</h2><p>应用层:</p><ul><li>coin mixing</li></ul><p>网络层:</p><ul><li>TOR 洋葱路由</li></ul><h2 id="Zero-knowledge-proof"><a href="#Zero-knowledge-proof" class="headerlink" title="Zero-knowledge proof"></a>Zero-knowledge proof</h2><p>A 向 B 证明一个陈述是正确的，而不必透露正确之外的内容。</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211126183519831.png"></p><h1 id="Ethereum-以太坊"><a href="#Ethereum-以太坊" class="headerlink" title="Ethereum 以太坊"></a>Ethereum 以太坊</h1><p>ETH最小单位wei</p><p>创始人 Vitalik</p><ol><li>出块时间</li><li>基于ghost协议的共识机制</li><li>memory hard mining puzzle 计算密集型</li><li>pow -&gt; proof of stake</li><li>智能合约，记录历史状态，为了支持智能合约的回滚</li></ol><h2 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h2><ol><li><p>externally owned account</p><ol><li>balance余额</li><li>nonce 其实是counter，记录该账户交易次数，用来避免重放攻击</li></ol></li><li><p>smart contract account</p><ol><li>code</li><li>storage</li></ol></li></ol><h2 id="状态树、交易树、收据树"><a href="#状态树、交易树、收据树" class="headerlink" title="状态树、交易树、收据树"></a>状态树、交易树、收据树</h2><p>modified Merkle Patricia trie</p><p>recursive length profix</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127122117738.png"> </p><h2 id="GHOST"><a href="#GHOST" class="headerlink" title="GHOST"></a>GHOST</h2><p>叔父区块 7/8*3</p><p>叔父区块最多有两个</p><p>最长合法链如果包含叔链的交易，那么总共会获得2*1/32*3+3</p><p>最多6代 7/8～2/8</p><h2 id="权益证明"><a href="#权益证明" class="headerlink" title="权益证明"></a>权益证明</h2><p>虚拟挖矿</p><p>pow的系统不是一个闭环，刚诞生的会面临AltCoin Infanticide，也就是外界的美元通过挖矿转化成币，从而让这一币种的价格暴跌</p><p>pos系统是一个闭环，挖矿难度由持有的币决定</p><p>以太坊中准备使用Casper the Friendly Finality Gadget</p><ol><li>对某个epoch是否是finality用保证金进行两轮投票</li><li>对验证者进行奖励和处罚，发现对两条链下注的就没收保证金</li></ol><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>solidity</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127161431761.png"> </p><blockquote><p>不支持hash表遍历，用一个数组保存</p><p>hash表所有值初始为0</p><p>不支持多线程</p></blockquote><p> <img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127163017087.png"></p><p> <img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127163621440.png"></p><p><strong>问题</strong>：以太坊中所有全节点都要在本地回滚自己的三棵树，并独立验证别人新发布的区块的正确性，这样得不到任何好处。他们不去验证直接认为某个新区块是正确的怎么办？</p><p><strong>解决</strong>：本地必须保证三棵树的正确性才能继续往下挖，所以一定会更新</p><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127213749740.png"></p><h2 id="拍卖auction"><a href="#拍卖auction" class="headerlink" title="拍卖auction"></a>拍卖auction</h2><p><img src="/2021/12/04/%E5%8C%97%E5%A4%A7%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127214840557.png"></p><p>code is law</p><p>irrecocable trust不可撤消的信托</p><p>智能合约一定要反复测试再发布</p><p>Irrevocability is a double edged sword.</p><p>Nothing is irrevocable.</p><h2 id="DAO-decentralized-autonomous-organization"><a href="#DAO-decentralized-autonomous-organization" class="headerlink" title="DAO-decentralized autonomous organization"></a>DAO-decentralized autonomous organization</h2><p>The DAO 众筹的智能合约</p><p>too big to fail</p><p>硬分叉之后，旧链改名为ETC，新链沿用ETH</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol><li><p>Is solidity the right programming language?</p></li><li><p>formal verification 是否应该研究？能否实现？</p></li><li><p>专门的模板和编写机构</p></li><li><p>开源也会存在安全漏洞，many eyeball fallacy虽然看的人很多，但看懂的很少，都以为别人看过</p></li><li><p>规则修改用去中心化的方法完成</p></li><li><p>在互不信任的实体建立共识才需要智能合约，其他分布式场景用不到</p></li></ol><h1 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h1><p>不是哪都能用，不应该和已有的支付方式竞争</p><ol><li>Information can flow freely on the Internet, but payment cannot.</li><li>民主不是最好的方案，只是最不坏的方案</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记得比较琐碎，以太坊部分待补充完整&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;BTC-密码学原理&quot;&gt;&lt;a href=&quot;#BTC-密码学原理&quot; class=&quot;headerlink&quot; title=&quot;BTC-密码学原理&quot;&gt;&lt;/a&gt;BTC-密码学原理&lt;/h1&gt;&lt;p&gt;比特币最小单位satoshi&lt;/p&gt;
&lt;p&gt;crypto-currency	加密货币&lt;/p&gt;
&lt;p&gt;cryptographic hash function	密码哈希函数&lt;/p&gt;
&lt;h2 id=&quot;哈希函数的性质&quot;&gt;&lt;a href=&quot;#哈希函数的性质&quot; class=&quot;headerlink&quot; title=&quot;哈希函数的性质&quot;&gt;&lt;/a&gt;哈希函数的性质&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;collision resistance&lt;/strong&gt;	冲突阻碍，指会发生哈希冲突的两个输入难以用某个高效算法找到&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;由实践经验得出某些哈希函数无法人为制造哈希碰撞，这一点无法在数学上证明&lt;/p&gt;
&lt;p&gt;另一些算法，如MD5 已经被破解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	brute-force	暴力破解，指用穷举法破解&lt;/p&gt;
&lt;p&gt;​	message digest	信息摘要/指纹，指利用冲突阻碍原理，信息被篡改后哈希值不改变的情况难以找到&lt;/p&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="Blockchain" scheme="http://example.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>A Peek Into the Reasoning of Neural Networks Interpreting with Structural Visual Concepts</title>
    <link href="http://example.com/2021/11/15/A-Peek-Into-the-Reasoning-of-Neural-Networks-Interpreting-with-Structural-Visual-Concepts/"/>
    <id>http://example.com/2021/11/15/A-Peek-Into-the-Reasoning-of-Neural-Networks-Interpreting-with-Structural-Visual-Concepts/</id>
    <published>2021-11-15T09:05:32.000Z</published>
    <updated>2022-10-09T08:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为《两小时读论文系列第一篇》，完成于2021-11-10</p><p>该论文发表于CVPR2021</p><p>难度：<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>文章地址：<a href="https://arxiv.org/abs/2105.00290">https://arxiv.org/abs/2105.00290</a></p><p>PPT展示：<a href="https://www.youtube.com/watch?v=ZzkpUrK-cRA">https://www.youtube.com/watch?v=ZzkpUrK-cRA</a></p><p>code: <a href="https://github.com/gyhandy/Visual-Reasoning-eXplanation">https://github.com/gyhandy/Visual-Reasoning-eXplanation</a></p></blockquote><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><p>框架名：VRX, visual reasoning explanation</p><ol><li>提取比特征更高阶的：视觉概念</li><li>按概念之间的关系组成有向有权图</li><li>用GNN聚合图结构信息，给出为什么这样预测和为什么不预测成别的标签的解释</li><li>副产品：可以给出预测错误的原因</li></ol><span id="more"></span><h1 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h1><p><img src="/2021/11/15/A-Peek-Into-the-Reasoning-of-Neural-Networks-Interpreting-with-Structural-Visual-Concepts/image-20211110153323457.png"></p><ol><li>VCE (Visual Concept Extractor) : Grad-Cam的attention map过滤背景，用ACE (SLIC分割 -&gt; patch resize -&gt; patch2vec -&gt; 聚类 -&gt; TCAV) 得到最重要的四个视觉概念</li><li>SCG (Structural Concept Graph) : 按照人脑的思维方式，四个概念的空间相对关系应该是确定的。对四个视觉概念按空间结构构图。</li><li>GRN (Graph Reasoning Network) :  传统的卷积+全连接的模型已经能达到80%以上的正确率。但是全连接部分很难解耦，信息流动不透明，这部分难以解释；GRN 由图卷积和一个简单的 MLP 组成；用知识蒸馏使得 GRN 和原模型决策一致；因为 GRN 是解耦的、易追踪的、可解释的模型，那么就可以用 GRN 以及之前的 VCE 和 SCG 来解释传统的 CNN 模型。</li><li>VDI (Visual Decision Interpreter) : 该研究提出了基于梯度的贡献度分配算法，为每个参与决策的点（视觉概念）和边（概念之间的关系）计算其对于特定决策的贡献值，贡献值的高低代表了其肯定还是否定了该决策。</li></ol><h1 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h1><ol><li><p>SCG: 节点表示最重要的四个视觉概念，检测不足四个，则用黑色的节点补满。边是有向有权的，由空间距离和依赖系数组成，后者是可训练参数，作者认为这个参数能在训练完成后揭示概念之间的隐含关系。</p><blockquote><p>SCG是如何部分删减的？原图中写的是选择重要的边，文中找不到，个人认为是根据计算完成后的权重离0的距离选的</p></blockquote></li><li><p>训练中，所有类别的结构概念图共享一套图卷积的参数，但是每个类别在消息传递中有专属的注意力权重参数 $e_{ji}$，类别专属的注意力权重参数是为了学习每个类别独特的视觉概念之间的空间和依赖关系。</p></li><li><p>为了提升模拟的鲁棒性，该研究还用 <strong>mask out 视觉概念添加扰动</strong>的方法使得概念图推理网络与被解释的原网络在面对扰动时决策一致。</p></li></ol><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ol><li><p>研究者用 VRX 对错误原因背后推理逻辑的解释作为修改建议，通过<strong>视觉概念（节点）的替换和删除</strong>，以及<strong>空间关系（边）的多样性扩充</strong>，原网络的错分可以被纠正。最终，VRX 将其错误总结为三种类别：</p><p><img src="/2021/11/15/A-Peek-Into-the-Reasoning-of-Neural-Networks-Interpreting-with-Structural-Visual-Concepts/image-20211110185737339.png"></p></li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://github.com/gyhandy/Visual-Reasoning-eXplanation">https://github.com/gyhandy/Visual-Reasoning-eXplanation</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文为《两小时读论文系列第一篇》，完成于2021-11-10&lt;/p&gt;
&lt;p&gt;该论文发表于CVPR2021&lt;/p&gt;
&lt;p&gt;难度：&lt;span class=&quot;github-emoji&quot;&gt;&lt;span&gt;⭐&lt;/span&gt;&lt;img src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8&quot; aria-hidden=&quot;true&quot; onerror=&quot;this.parent.classList.add(&#39;github-emoji-fallback&#39;)&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;文章地址：&lt;a href=&quot;https://arxiv.org/abs/2105.00290&quot;&gt;https://arxiv.org/abs/2105.00290&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PPT展示：&lt;a href=&quot;https://www.youtube.com/watch?v=ZzkpUrK-cRA&quot;&gt;https://www.youtube.com/watch?v=ZzkpUrK-cRA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;code: &lt;a href=&quot;https://github.com/gyhandy/Visual-Reasoning-eXplanation&quot;&gt;https://github.com/gyhandy/Visual-Reasoning-eXplanation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Idea&quot;&gt;&lt;a href=&quot;#Idea&quot; class=&quot;headerlink&quot; title=&quot;Idea&quot;&gt;&lt;/a&gt;Idea&lt;/h1&gt;&lt;p&gt;框架名：VRX, visual reasoning explanation&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提取比特征更高阶的：视觉概念&lt;/li&gt;
&lt;li&gt;按概念之间的关系组成有向有权图&lt;/li&gt;
&lt;li&gt;用GNN聚合图结构信息，给出为什么这样预测和为什么不预测成别的标签的解释&lt;/li&gt;
&lt;li&gt;副产品：可以给出预测错误的原因&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="paper-reading" scheme="http://example.com/categories/paper-reading/"/>
    
    
    <category term="CV" scheme="http://example.com/tags/CV/"/>
    
    <category term="GNN" scheme="http://example.com/tags/GNN/"/>
    
    <category term="Interpretability" scheme="http://example.com/tags/Interpretability/"/>
    
  </entry>
  
  <entry>
    <title>GAN初识</title>
    <link href="http://example.com/2021/11/02/GAN%E5%88%9D%E8%AF%86/"/>
    <id>http://example.com/2021/11/02/GAN%E5%88%9D%E8%AF%86/</id>
    <published>2021-11-02T14:25:35.000Z</published>
    <updated>2022-10-14T04:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>生成对抗网络，Generative Adversarial Network (GAN) , 发明于2014年，是一种无监督学习的方法。最初的GAN由一个生成器和一个判别器组成：生成器把噪声作为输入，尽可能生成以假乱真的样本；判别器以真实样本和生成样本作为输入，输出样本真假判断的结果。最终能从训练好的生成器中输出高质量的，甚至超过真实样本的结果。生成器学习到的是鉴别器认同的数据的分布，如果从某个通常的隐空间（标准正态分布）冷启动，那么它学习的是分布变换的过程。</p><blockquote><p>Goodfellow, Ian J.; Pouget-Abadie, Jean; Mirza, Mehdi; Xu, Bing; Warde-Farley, David; Ozair, Sherjil; Courville, Aaron; Bengio, Yoshua. Generative Adversarial Networks. 2014. <a href="https://arxiv.org/abs/1406.2661">arXiv:1406.2661</a></p></blockquote><span id="more"></span><p><img src="/2021/11/02/GAN%E5%88%9D%E8%AF%86/2019-07-15-124947.jpg" alt="MNIST手写数字+ GAN架构"></p><h1 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h1><p><img src="/2021/11/02/GAN%E5%88%9D%E8%AF%86/image-20211204155049112.png"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>最基础的GAN实现</p><pre><code class="python"># Ubuntu 16.04# tensorflow 2.5, CUDA 11.2import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport PILimport timeimport osfrom tensorflow.keras import layers(train_images, train_labels), (_, _) = tf.keras.datasets.mnist.load_data()# 加了一维:通道数=1train_images = train_images.reshape(train_images.shape[0], 28, 28, 1).astype('float')train_images = (train_images - 127.5) / 127.5BUFFER_SIZE = 60000BATCH_SIZE = 256EPOCHS = 50noise_dim = 100num_examples_to_generate = 16train_dataset = tf.data.Dataset.from_tensor_slices(train_images).shuffle(BUFFER_SIZE).batch(BATCH_SIZE)# 生成器，输入N*100def make_generator_model():    model = tf.keras.Sequential()    model.add(layers.Dense(7 * 7 * 256, use_bias=False, input_shape=(100,)))    model.add(layers.BatchNormalization())    model.add(layers.LeakyReLU())    model.add(layers.Reshape((7, 7, 256)))    assert model.output_shape == (None, 7, 7, 256)    model.add(layers.Conv2DTranspose(128, (5, 5), strides=(1, 1), padding='same', use_bias=False))    assert model.output_shape == (None, 7, 7, 128)    model.add(layers.BatchNormalization())    model.add(layers.LeakyReLU())    model.add(layers.Conv2DTranspose(64, (5, 5), strides=(2, 2), padding='same', use_bias=False))    assert model.output_shape == (None, 14, 14, 64)    model.add(layers.BatchNormalization())    model.add(layers.LeakyReLU())    model.add(layers.Conv2DTranspose(1, (5, 5), strides=(2, 2), padding='same', use_bias=False, activation='tanh'))    assert model.output_shape == (None, 28, 28, 1)    return modelgenerator = make_generator_model()# generate 1*100 normal distribution# noise = tf.random.normal([1, 100])# generated_image = generator(noise, training=False)# discriminator,input N*28*28*1def make_discriminator_model():    model = tf.keras.Sequential()    model.add(layers.Conv2D(64, (5, 5), strides=(2, 2), padding='same',                            input_shape=[28, 28, 1]))    model.add(layers.LeakyReLU())    model.add(layers.Dropout(0.3))    model.add(layers.Conv2D(128, (5, 5), strides=(2, 2), padding='same'))    model.add(layers.LeakyReLU())    model.add(layers.Dropout(0.3))    model.add(layers.Flatten())    model.add(layers.Dense(1))    return modeldiscriminator = make_discriminator_model()cross_entropy = tf.keras.losses.BinaryCrossentropy(from_logits=True)# the more ones in real_output and zeros in fake_output, the better the discriminator isdef discriminator_loss(real_output, fake_output):    real_loss = cross_entropy(tf.ones_like(real_output), real_output)    fake_loss = cross_entropy(tf.zeros_like(fake_output), fake_output)    total_loss = real_loss + fake_loss    return total_loss# the more zeros in fake_output, the worse generator isdef generator_loss(fake_output):    return cross_entropy(tf.ones_like(fake_output), fake_output)# same learning rategenerator_optimizer = tf.keras.optimizers.Adam(1e-4)discriminator_optimizer = tf.keras.optimizers.Adam(1e-4)@tf.functiondef train_step(images):    noise = tf.random.normal([BATCH_SIZE, noise_dim])    with tf.GradientTape() as gen_tape, tf.GradientTape() as disc_tape:        generated_images = generator(noise, training=True)        real_output = discriminator(images, training=True)        fake_output = discriminator(generated_images, training=True)        gen_loss = generator_loss(fake_output)        disc_loss = discriminator_loss(real_output, fake_output)    gradients_of_generator = gen_tape.gradient(gen_loss, generator.trainable_variables)    gradients_of_discriminator = disc_tape.gradient(disc_loss, discriminator.trainable_variables)    generator_optimizer.apply_gradients(zip(gradients_of_generator, generator.trainable_variables))    discriminator_optimizer.apply_gradients(zip(gradients_of_discriminator, discriminator.trainable_variables))checkpoint_dir = './training_checkpoints'checkpoint_prefix = os.path.join(checkpoint_dir, "ckpt")checkpoint = tf.train.Checkpoint(generator_optimizer=generator_optimizer,                                 discriminator_optimizer=discriminator_optimizer,                                 generator=generator,                                 discriminator=discriminator)seed = tf.random.normal([num_examples_to_generate, noise_dim])# for every epochs, for every batch, 256 real image + 256 fake image# after one epochs, generate 16 fake image to show the growth of generatordef train(dataset, epochs):    for epoch in range(epochs):        start = time.time()        for image_batch in dataset:            train_step(image_batch)        generate_and_save_images(generator,                                 epoch + 1,                                 seed)        # Save the model every 15 epochs        if (epoch + 1) % 15 == 0:            checkpoint.save(file_prefix=checkpoint_prefix)        print('Time for epoch {} is {} sec'.format(epoch + 1, time.time() - start))    # Generate after the final epoch    generate_and_save_images(generator,                             epochs,                             seed)def generate_and_save_images(model, epoch, test_input):    predictions = model(test_input, training=False)    fig = plt.figure(figsize=(4, 4))    for i in range(predictions.shape[0]):        plt.subplot(4, 4, i + 1)        plt.imshow(predictions[i, :, :, 0] * 127.5 + 127.5, cmap='gray')        plt.axis('off')    plt.savefig('image_at_epoch_{:04d}.png'.format(epoch))if __name__ == '__main__':    train(train_dataset,EPOCHS)</code></pre><p><a href="https://www.tensorflow.org/tutorials/generative/dcgan?hl=zh-cn">代码参考</a></p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><ul><li><p>DCGAN 去掉池化层、全连接层，使用BN层</p></li><li><p>PGAN 能处理1024*1024的图片</p></li><li><p>SAGAN 加入自注意力机制</p><p><a href="https://www.paperweekly.site/papers/notes/414">SAGAN论文解读</a></p></li><li><p>StyleGAN 生成器各层都输入噪声，噪声由多个全连接层生成</p><p><a href="https://zhuanlan.zhihu.com/p/263554045">StyleGAN 和 StyleGAN2 的深度理解</a></p></li><li><p>BigGAN <img src="/2021/11/02/GAN%E5%88%9D%E8%AF%86/v2-914466c51bb79895c857360a33be982b_720w.jpg"></p><blockquote><p>噪声向量 z 的块和条件标签 c 在残差块下是通过 concat 操作后送入 BatchNorm 层</p></blockquote><ul><li>发现增大 batchsize 能提高生成效果</li><li>对先验分布 z 设置阈值来对样本<strong>多样性</strong>和<strong>保真度</strong>进行控制</li></ul><p><a href="https://zhuanlan.zhihu.com/p/46581611">深度解读DeepMind新作：史上最强GAN图像生成器—BigGAN</a></p></li><li><p>U-Net 判别器输出全局和局部像素决策 </p><p><a href="https://blog.csdn.net/u014546828/article/details/111244358">MyDLNote-Network: 2020 CVPR 基于 U-Net 判别器的生成对抗网络 A U-Net Based Discriminator for Generative Adversari</a></p></li><li><p>multi-modal</p></li></ul><p><img src="/2021/11/02/GAN%E5%88%9D%E8%AF%86/image-20211101163841571.png"></p><h2 id="条件输入"><a href="#条件输入" class="headerlink" title="条件输入"></a>条件输入</h2><ul><li><p>原始的 GAN 基于噪声作为生成器的输入，一次生成所有类别的图像，无法生成指定图像。</p></li><li><p>CGAN 将类别标签和噪声拼接输入生成器</p></li><li><p>ACGAN 判别器输出真假和类别</p></li><li><p>CGAN with Projection Discriminator 判别器的中间feature和条件信息进行点乘</p></li></ul><h2 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h2><ul><li>BN -&gt; Pixelwise Normalization/equalized learning rate -&gt; Spectral Normalization -&gt; Wasserstein Distance</li></ul><h2 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h2><ul><li><p>stochastic discriminator augmentation</p></li><li><p>Adaptive discriminator augmentation</p></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul><li><p>分类：CatGAN</p></li><li><p>生成：风格迁移、去雨去雾、去马赛克、超分辨率、虚拟换衣、换脸、表情、年龄、妆容迁移</p></li><li><p>生成人脸解决数据来源的隐私问题</p></li><li><p>生成图片用于数据增强</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzU5MTgzNzE0MA==&amp;mid=2247483674&amp;idx=1&amp;sn=4370e8bb00f456bd1f3ad09e4adb7c56&amp;scene=21#wechat_redirect">GAN整整6年了！是时候要来捋捋了！</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;生成对抗网络，Generative Adversarial Network (GAN) , 发明于2014年，是一种无监督学习的方法。最初的GAN由一个生成器和一个判别器组成：生成器把噪声作为输入，尽可能生成以假乱真的样本；判别器以真实样本和生成样本作为输入，输出样本真假判断的结果。最终能从训练好的生成器中输出高质量的，甚至超过真实样本的结果。生成器学习到的是鉴别器认同的数据的分布，如果从某个通常的隐空间（标准正态分布）冷启动，那么它学习的是分布变换的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Goodfellow, Ian J.; Pouget-Abadie, Jean; Mirza, Mehdi; Xu, Bing; Warde-Farley, David; Ozair, Sherjil; Courville, Aaron; Bengio, Yoshua. Generative Adversarial Networks. 2014. &lt;a href=&quot;https://arxiv.org/abs/1406.2661&quot;&gt;arXiv:1406.2661&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="GAN" scheme="http://example.com/tags/GAN/"/>
    
  </entry>
  
  <entry>
    <title>muxViz 使用指南</title>
    <link href="http://example.com/2021/10/18/muxViz-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/10/18/muxViz-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-10-18T05:44:39.000Z</published>
    <updated>2022-10-09T08:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>安装R-studio、R</li><li>muxViz-3.1（无GUI）：<a href="https://github.com/manlius/muxViz">https://github.com/manlius/muxViz</a></li><li>muxViz-2.0（GUI）：<a href="https://github.com/wjj0301/Multiplex-Networks">https://github.com/wjj0301/Multiplex-Networks</a></li></ol><h1 id="输入数据格式"><a href="#输入数据格式" class="headerlink" title="输入数据格式"></a>输入数据格式</h1><pre><code class="shell"># config.txtpath_multilayer; path_to_layers_info; path_to_layers_layout# 或者每层对应一个文件path_layer_X; label_layer_X; path_to_layout_layer_X...</code></pre><pre><code class="shell"># layers.txt# 层信息layerID layerLabel1 L12 L23 L3...</code></pre><pre><code class="shell"># .edges# 层内连边关系，无headline# 依次为 源节点ID、层ID、目标节点ID、层ID、边权值1 1 53 1 3                                                                     2 1 94 1 42 1 165 1 7...# 层间连边关系，对于multiplex，节点ID相同1 1 1 22 1 2 2...</code></pre><pre><code class="shell"># layout.txt# 节点信息，可选，加入此文件后，edges文件nodeID可直接换成nodeLabelnodeID nodeLabel1 n12 n23 n3...</code></pre><span id="more"></span><h2 id="时间轴文件格式"><a href="#时间轴文件格式" class="headerlink" title="时间轴文件格式"></a>时间轴文件格式</h2><p>这个模块允许在多层网络的顶部建立与动态过程相对应的动画，未尝识</p><h2 id="导入R"><a href="#导入R" class="headerlink" title="导入R"></a>导入R</h2><pre><code class="R">buildMultilayerNetworkFromMuxvizFiles(  config.file,  isDirected,  isWeighted,  MultisliceType,  LayerCouplingStrength = 1,  format = "muxviz edge-colored", # or "muxviz general"  verbose = T)</code></pre><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><h2 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h2><pre><code class="R">library(RColorBrewer)library(viridis)</code></pre><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><pre><code class="R">library(muxViz)library(igraph)library(rgl)set.seed(1)# Network setupLayers &lt;- 3Nodes &lt;- 200layerCouplingStrength &lt;- 1networkOfLayersType &lt;- "categorical"isDirected &lt;- Flayer.colors &lt;- brewer.pal(8, "Set2")pathInfomap &lt;- "infomap-0.x/Infomap"nodeTensor &lt;- list()g.list &lt;- list()# 每层社团数plantedGroupsPerLayer &lt;- 4# matrix of the stochastic block modelblock.matrix &lt;- matrix(0.1 / Nodes, plantedGroupsPerLayer,                       plantedGroupsPerLayer)diag(block.matrix) &lt;- 2 * log(Nodes) / Nodes# 总节点数平均分给四个社团block.sizes &lt;- rep(floor(Nodes / plantedGroupsPerLayer), plantedGroupsPerLayer)for (l in 1:Layers) {  #Generate the layers  #双中括号提取修改元素  g.list[[l]] &lt;- sample_sbm(Nodes, pref.matrix=block.matrix,                            block.sizes=block.sizes)    #Get the list of adjacency matrices which build the multiplex  nodeTensor[[l]] &lt;- get.adjacency(g.list[[l]])  #定义布局方式 "fr","drl", "auto", "kk", "comp", "dh"  lay &lt;- layoutMultiplex(g.list, layout="fr", ggplot.format=F, box=T)    # Show the multiplex network  plot_multiplex3D(g.list, layer.layout=lay, layer.colors=layer.colors,                   layer.shift.x=0.5, layer.space=2,                   layer.labels="auto", layer.labels.cex=1.5,                   node.size.values="auto", node.size.scale=0.8,                   show.aggregate=T)  # 导出，有问题  snapshot3d("../man/figures/multi_sbm.png", fmt = "png", width = 1024, height = 1024)}</code></pre><p><a href="https://manlius.github.io/muxViz/reference/plot_multiplex3D.html">https://manlius.github.io/muxViz/reference/plot_multiplex3D.html</a></p><h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><p>左键拖动整体旋转，右键按拖动方向改变各层散射角度，中键拖动缩放</p><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>linux下有问题，win下操作</p><ul><li><p>multiplex 要画出层间连线只能用GUI，muxViz未提供接口，GUI源码仍然使用igraph，只能从sever.R中剥离此函数</p></li><li><p>GUI中给出不同节点或边指定颜色的接口，使用后闪退；可以按GUI的社团检测结果给出颜色</p></li><li><p>多层社团检测使用后闪退</p></li></ul><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>win和linux下都有问题，建议直接截图</p><h1 id="图数据分析"><a href="#图数据分析" class="headerlink" title="图数据分析"></a>图数据分析</h1><h2 id="单层指标"><a href="#单层指标" class="headerlink" title="单层指标"></a>单层指标</h2><h2 id="多层指标"><a href="#多层指标" class="headerlink" title="多层指标"></a>多层指标</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;安装R-studio、R&lt;/li&gt;
&lt;li&gt;muxViz-3.1（无GUI）：&lt;a href=&quot;https://github.com/manlius/muxViz&quot;&gt;https://github.com/manlius/muxViz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;muxViz-2.0（GUI）：&lt;a href=&quot;https://github.com/wjj0301/Multiplex-Networks&quot;&gt;https://github.com/wjj0301/Multiplex-Networks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;输入数据格式&quot;&gt;&lt;a href=&quot;#输入数据格式&quot; class=&quot;headerlink&quot; title=&quot;输入数据格式&quot;&gt;&lt;/a&gt;输入数据格式&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# config.txt

path_multilayer; path_to_layers_info; path_to_layers_layout
# 或者每层对应一个文件
path_layer_X; label_layer_X; path_to_layout_layer_X
...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# layers.txt
# 层信息

layerID layerLabel
1 L1
2 L2
3 L3
...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# .edges
# 层内连边关系，无headline
# 依次为 源节点ID、层ID、目标节点ID、层ID、边权值
1 1 53 1 3                                                                     
2 1 94 1 4
2 1 165 1 7
...

# 层间连边关系，对于multiplex，节点ID相同
1 1 1 2
2 1 2 2
...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# layout.txt
# 节点信息，可选，加入此文件后，edges文件nodeID可直接换成nodeLabel

nodeID nodeLabel
1 n1
2 n2
3 n3
...
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="R" scheme="http://example.com/tags/R/"/>
    
    <category term="interpretable" scheme="http://example.com/tags/interpretable/"/>
    
  </entry>
  
  <entry>
    <title>task workflow</title>
    <link href="http://example.com/2021/10/14/task-workflow/"/>
    <id>http://example.com/2021/10/14/task-workflow/</id>
    <published>2021-10-14T01:48:38.000Z</published>
    <updated>2022-10-09T08:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Taskwarrior-使用指南"><a href="#Taskwarrior-使用指南" class="headerlink" title="Taskwarrior 使用指南"></a>Taskwarrior 使用指南</h1><blockquote><p>Linux 命令行任务管理软件</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="shell"># Arch/Manjarosudo pacman -S tasksudo pacman -S taskwarrior-tui# ~/.bashrcalias tt="taskwarrior-tui"</code></pre><h1 id="开始第一个任务"><a href="#开始第一个任务" class="headerlink" title="开始第一个任务"></a>开始第一个任务</h1><p>项目划分出任务，类似于其他软件的主任务和子任务，但taskwarrior里只能两层</p><pre><code class="shell"># 尽量一条长语句说明task add 任务名 project:项目名 due:eow # 发现重现不了的bugtask ID delete Could not reproduce bug +cannot_reproduce</code></pre><span id="more"></span><h1 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h1><h2 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h2><pre><code class="shell">task add Send Alice a birthday card \           due:2016-11-08 \           scheduled:2016-11-04 \           wait:november           until:2016-11-10</code></pre><p>due: 任务完成的预计时间</p><p>scheduled: 任务开始的预计时间</p><p>wait: 任务在列表里出现的时间，<code>task list</code>会自动过滤，可以用<code>task waiting</code>查看</p><p>until: 任务自行销毁的时间</p><h2 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h2><p><strong>基本格式：YYYY-MM-DDThh:mm</strong></p><ul><li>可以YYYY-MM、YYYY-MM-DD、hh:mm</li><li>所有有歧义的都按最早的算</li><li>也可按时间跨度，3d、3h</li></ul><table><thead><tr><th>快捷命令</th><th>注释</th></tr></thead><tbody><tr><td><code>now</code></td><td>Current local date and time.</td></tr><tr><td><code>today</code></td><td>Current local date, with time 00:00:00.</td></tr><tr><td><code>sod</code></td><td>Local date of the start of the next day, with time 00:00:00. Same as <code>tomorrow</code>.</td></tr><tr><td><code>eod</code></td><td>Current local date, with time 23:59:59.</td></tr><tr><td><code>yesterday</code></td><td>Local date for yesterday, with time 00:00:00.</td></tr><tr><td><code>tomorrow</code></td><td>Local date for tomorrow, with time 00:00:00. Same as <code>sod</code>.</td></tr><tr><td><code>monday</code>, <code>tuesday</code> …</td><td>Local date for the specified day, after today, with time 00:00:00. Can be shortened, e.g. <code>mon</code>, <code>tue</code> <strong>2.6.0</strong> Can be capitalized, e.g. <code>Monday</code>, <code>Tue</code></td></tr><tr><td><code>january</code>, <code>february</code> …</td><td>Local date for the specified month, 1st day, with time 00:00:00. Can be shortened, e.g. <code>jan</code>, <code>feb</code>. <strong>2.6.0</strong> Can be capitalized, e.g. <code>January</code>, <code>Feb</code>.</td></tr><tr><td><code>later</code>, <code>someday</code></td><td>Local 2038-01-18, with time 00:00:00. A date far away, with semantically meaningful to GTD users.</td></tr><tr><td><code>soy</code></td><td>Local date for the next year, January 1st, with time 00:00:00.</td></tr><tr><td><code>eoy</code></td><td>Local date for this year, December 31st, with time 00:00:00.</td></tr><tr><td><code>soq</code></td><td>Local date for the start of the next quarter (January, April, July, October), 1st, with time 00:00:00.</td></tr><tr><td><code>eoq</code></td><td>Local date for the end of the current quarter (March, June, September, December), last day of the month, with time 23:59:59.</td></tr><tr><td><code>som</code></td><td>Local date for the 1st day of the next month, with time 00:00:00.</td></tr><tr><td><code>socm</code></td><td>Local date for the 1st day of the current month, with time 00:00:00.</td></tr><tr><td><code>eom</code>, <code>eocm</code></td><td>Local date for the last day of the current month, with time 23:59:59.</td></tr><tr><td><code>sow</code></td><td>Local date for the next Sunday, with time 00:00:00.</td></tr><tr><td><code>socw</code></td><td>Local date for the last Sunday, with time 00:00:00.</td></tr><tr><td><code>eow</code>, <code>eocw</code></td><td>Local date for the end of the week, Saturday night, with time 00:00:00.</td></tr><tr><td><code>soww</code></td><td>Local date for the start of the work week, next Monday, with time 00:00:00.</td></tr><tr><td><code>eoww</code></td><td>Local date for the end of the work week, Friday night, with time 23:59:59.</td></tr><tr><td><code>1st</code>, <code>2nd</code>, …</td><td>Local date for the next Nth day, with time 00:00:00.</td></tr></tbody></table><h1 id="urgency值"><a href="#urgency值" class="headerlink" title="urgency值"></a>urgency值</h1><pre><code class="shell">urgency.user.tag.next.coefficient           15.0 # +next 标签urgency.due.coefficient                     12.0 # 过期或临近ddlurgency.blocking.coefficient                 8.0 # 阻塞其他任务urgency.uda.priority.H.coefficient           6.0 # 设为高优先级urgency.uda.priority.M.coefficient           3.9 # 设为中优先级urgency.uda.priority.L.coefficient           1.8 # 设为低优先级urgency.scheduled.coefficient                5.0 # 定了预定时间的任务urgency.active.coefficient                   4.0 # 激活的任务urgency.age.coefficient                      2.0 # 根据任务创建时间urgency.annotations.coefficient              1.0 # 添加了注释urgency.tags.coefficient                     1.0 # 添加了标签urgency.project.coefficient                  1.0 # 属于某个项目urgency.user.project.My Project.coefficient  5.0 # 属于高优先级的某个项目urgency.waiting.coefficient                 -3.0 # 等待中的任务urgency.blocked.coefficient                 -5.0 # 阻塞中的任务</code></pre><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><p>定义上下文，通过tag的代数表达式过滤任务</p><pre><code>task context define work +work or +freelancetask context define study +school or +homework or +labtask context define home -work -freelance -school -homework -lab</code></pre><pre><code class="shell"># 查看已经创建的上下文task context show# 切换上下文task context work</code></pre><h1 id="modify"><a href="#modify" class="headerlink" title="modify"></a>modify</h1><pre><code class="shell"># 设置依赖# 79任务所依赖的78任务未完成，A任务状态为blockedtask 79 modify depends:78# 删除某个属性task 1 modify due:# 修改描述task ID modify ...# 修改属性task ID modify project:Hometask ID modify priority:Mtask ID modify +problem +house</code></pre><h1 id="过滤和虚拟标签"><a href="#过滤和虚拟标签" class="headerlink" title="过滤和虚拟标签"></a>过滤和虚拟标签</h1><p>通常用状态、所属项目、标签来过滤。</p><pre><code class="shell">status:pending and project:Home or -work</code></pre><p>要用时间来过滤，比如我们要过滤出今晚12:00前到期的任务。</p><pre><code class="shell">task due.after:yesterday and due.before:tomorrow list</code></pre><p>这样写很麻烦，2.2版本后加入了虚拟标签，请不要用自定义标签占用它们。</p><p>上面的过滤可以简化为</p><pre><code class="shell">task +TODAY list</code></pre><table><thead><tr><th>虚拟标签</th><th>注释</th></tr></thead><tbody><tr><td><code>BLOCKED</code></td><td>Is the task dependent on another incomplete task?</td></tr><tr><td><code>UNBLOCKED</code></td><td>The opposite of BLOCKED, for convenience. Note +BLOCKED == -UNBLOCKED and vice versa.</td></tr><tr><td><code>BLOCKING</code></td><td>Does another task depend on this incomplete task?</td></tr><tr><td><code>DUE</code></td><td>Is this task due within 7 days? Determined by rc.due</td></tr><tr><td><code>DUETODAY</code></td><td>Is this task due sometime today?</td></tr><tr><td><code>TODAY</code></td><td>Is this task due sometime today?</td></tr><tr><td><code>OVERDUE</code></td><td>Is this task past it’s due date?</td></tr><tr><td><code>WEEK</code></td><td>Is this task due this week? <strong>2.3.0</strong></td></tr><tr><td><code>MONTH</code></td><td>Is this task due this month? <strong>2.3.0</strong></td></tr><tr><td><code>QUARTER</code></td><td>Is this task due this quarter? <strong>2.6.0</strong></td></tr><tr><td><code>YEAR</code></td><td>Is this task due this year? <strong>2.3.0</strong></td></tr><tr><td><code>ACTIVE</code></td><td>Is the task active, ie does it have a start date?</td></tr><tr><td><code>SCHEDULED</code></td><td>Is the task scheduled, ie does it have a scheduled date?</td></tr><tr><td><code>PARENT</code></td><td>Is the task a hidden parent recurring task? <strong>2.3.0</strong></td></tr><tr><td><code>CHILD</code></td><td>Is the task a recurring child task?</td></tr><tr><td><code>UNTIL</code></td><td>Does the task expire, ie does it have an until date?</td></tr><tr><td><code>WAITING</code></td><td>Is the task hidden, ie does it have a wait date?</td></tr><tr><td><code>ANNOTATED</code></td><td>Does the task have any annotations?</td></tr><tr><td><code>READY</code></td><td>Is the task pending, not blocked, and either not scheduled, or scheduled before now. <strong>2.4.0</strong></td></tr><tr><td><code>YESTERDAY</code></td><td>Was the task due yesterday? <strong>2.4.0</strong></td></tr><tr><td><code>TOMORROW</code></td><td>Is the task due tomorrow? <strong>2.4.0</strong></td></tr><tr><td><code>TAGGED</code></td><td>Does the task have any tags?</td></tr><tr><td><code>PENDING</code></td><td>Is the task in the pending state? <strong>2.4.0</strong></td></tr><tr><td><code>COMPLETED</code></td><td>Is the task in the completed state? <strong>2.4.0</strong></td></tr><tr><td><code>DELETED</code></td><td>Is the task in the deleted state? <strong>2.4.0</strong></td></tr><tr><td><code>UDA</code></td><td>Does the task contain any UDA values? <strong>2.5.0</strong></td></tr><tr><td><code>ORPHAN</code></td><td>Does the task contain any orphaned UDA values? <strong>2.5.0</strong></td></tr><tr><td><code>PRIORITY</code></td><td>Does the task have a priority? <strong>2.5.0</strong></td></tr><tr><td><code>PROJECT</code></td><td>Does the task have a project? <strong>2.5.0</strong></td></tr><tr><td><code>LATEST</code></td><td>Is the task the most recently added task? <strong>2.5.0</strong></td></tr></tbody></table><h1 id="tt提供的快捷键"><a href="#tt提供的快捷键" class="headerlink" title="tt提供的快捷键"></a>tt提供的快捷键</h1><pre><code class="shell">uda.taskwarrior-tui.keyconfig.quit=quda.taskwarrior-tui.keyconfig.refresh=ruda.taskwarrior-tui.keyconfig.go-to-bottom=Guda.taskwarrior-tui.keyconfig.go-to-top=guda.taskwarrior-tui.keyconfig.down=juda.taskwarrior-tui.keyconfig.up=kuda.taskwarrior-tui.keyconfig.page-down=Juda.taskwarrior-tui.keyconfig.page-up=Kuda.taskwarrior-tui.keyconfig.delete=xuda.taskwarrior-tui.keyconfig.done=duda.taskwarrior-tui.keyconfig.start-stop=suda.taskwarrior-tui.keyconfig.undo=uuda.taskwarrior-tui.keyconfig.edit=euda.taskwarrior-tui.keyconfig.modify=muda.taskwarrior-tui.keyconfig.shell=!uda.taskwarrior-tui.keyconfig.log=luda.taskwarrior-tui.keyconfig.add=auda.taskwarrior-tui.keyconfig.annotate=Auda.taskwarrior-tui.keyconfig.filter=/uda.taskwarrior-tui.keyconfig.zoom=zuda.taskwarrior-tui.keyconfig.context-menu=cuda.taskwarrior-tui.keyconfig.next-tab=]uda.taskwarrior-tui.keyconfig.previous-tab=[</code></pre><h1 id="生成报告"><a href="#生成报告" class="headerlink" title="生成报告"></a>生成报告</h1><p><code>task ...</code></p><h2 id="内置静态报告"><a href="#内置静态报告" class="headerlink" title="内置静态报告"></a>内置静态报告</h2><pre><code>burndown.dailyburndown.monthlyburndown.weeklycalendarcolorsexportghistory.annualghistory.monthlyhistory.annualhistory.monthlyinformationsummarytimesheet</code></pre><h2 id="内置动态报告"><a href="#内置动态报告" class="headerlink" title="内置动态报告"></a>内置动态报告</h2><pre><code class="shell">activeallblockedblockingcompletedlistlonglsminimalnewestnextoldestoverduereadyrecurringunblockedwaiting</code></pre><h2 id="自定义报告"><a href="#自定义报告" class="headerlink" title="自定义报告"></a>自定义报告</h2><pre><code class="shell">task config report.simple.description 'Simple list of open tasks by project'task config report.simple.columns     'id,project,description.count'task config report.simple.labels      'ID,Proj,Desc'task config report.simple.sort        'project+/,entry+'task config report.simple.filter      'status:pending'task simple</code></pre><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>原来准备使用 <a href="https://inthe.am/">inthe.am</a> 提供的工具使其跟 <a href="https://trello.com/">trello</a> 同步，而trello支持win/macos/ios/linux/android。</p><p>inthe.am主页本身提供task的GUI功能，在浏览器上就可以多端同步。</p><p>在登录后, 按照 <a href="https://inthe.am/configure">Configuration &amp; Settings</a> 中的提示，下载三个文件，修改<code>~/.taskrc</code>，然后<code>task sync init</code>。之后通过 <code>task sync</code> 指令同步任务列表, 既可以达到跨平台同步的功能了。</p><blockquote><p>由于trello和taskwarrior功能逻辑不完全一致，建议不要在trello上操作，而是作为只读的看板</p></blockquote><h1 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h1><pre><code class="shell"># 自定义命令task config alias.rm delete# 自定义快捷键 ~/.taskrc# 这句由官方给出，但不生效#uda.taskwarrior-tui.keyconfig.shortcut1=Suda.taskwarrior-tui.shortcuts.1=task sync# 批量处理，在tt中按vtask 67,76-79 modify project:fosscontrib# 彻底删除deleted的任务,2.6新加入的特性，原来用过滤器隐藏task purge# 加入任务并标记为完成task log ...# 阻塞别的任务且不被别的任务阻塞优先级最高task +BLOCKING -BLOCKED</code></pre><h1 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h1><ol><li>每天早上打开manjaro<ol><li>sudo pacman -Syu</li><li>tt</li></ol></li><li>按以下优先级选择任务<ol><li>昨晚离开前仍处于start的任务</li><li>按urgency选择</li></ol></li><li>按s开始任务，按s搁置，完成后done，一段时间后delete</li><li>按1同步，现设置为每一小时自动同步</li><li><code>task burndown.monthly/weekly</code>查看报表</li><li>多端需求用inthe.am</li></ol><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p><a href="https://taskwarrior.org/docs/terminology.html">https://taskwarrior.org/docs/terminology.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://taskwarrior.org/docs/commands/">https://taskwarrior.org/docs/commands/</a></p><p><a href="https://kdheepak.com/taskwarrior-tui/">https://kdheepak.com/taskwarrior-tui/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Taskwarrior-使用指南&quot;&gt;&lt;a href=&quot;#Taskwarrior-使用指南&quot; class=&quot;headerlink&quot; title=&quot;Taskwarrior 使用指南&quot;&gt;&lt;/a&gt;Taskwarrior 使用指南&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Linux 命令行任务管理软件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# Arch/Manjaro
sudo pacman -S task
sudo pacman -S taskwarrior-tui

# ~/.bashrc
alias tt=&quot;taskwarrior-tui&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;开始第一个任务&quot;&gt;&lt;a href=&quot;#开始第一个任务&quot; class=&quot;headerlink&quot; title=&quot;开始第一个任务&quot;&gt;&lt;/a&gt;开始第一个任务&lt;/h1&gt;&lt;p&gt;项目划分出任务，类似于其他软件的主任务和子任务，但taskwarrior里只能两层&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 尽量一条长语句说明
task add 任务名 project:项目名 due:eow 

# 发现重现不了的bug
task ID delete Could not reproduce bug +cannot_reproduce
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>个人品牌的开始</title>
    <link href="http://example.com/2021/10/11/%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>http://example.com/2021/10/11/%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2021-10-11T13:47:33.000Z</published>
    <updated>2021-10-31T08:23:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><p>昨天看曾仕强教授的演讲，讲了个<strong>三季人</strong>的故事。就是说孔子的学生和一个路人争辩一年到底有几个季节，路人坚决认为是三个季节，孔子学生说明明是四个季节，两人吵得不可开交，只好请孔子来决断。孔子看了路人一眼就对学生说，一年是三个季节，你朝他磕个头承认错误吧。孔子的学生满怀不甘地磕了头，路人也高高兴兴地走了。时候，学生埋怨孔子为什么不坚持真理，孔子说：“你看那个家伙，衣服是绿的，就是只蚂蚱，活不过这个秋天，在他眼里，一年就是三季，你怎么争都不会有结果，还不如磕个头让他高高兴兴地离开。”在网络喷子和“杠精”横行的当下，这个故事颇有启发意义。</p><p>事实上人和人的差别比人和蚂蚱都要大，当今网络空间里的<strong>“三季人”</strong>我们见得太多了。逞口舌之快，开口就是祖宗十八代，自认为是龙吟虎啸，在别人眼里却不过是跳梁小丑。在他们的认知里，网络就是发泄情绪和暴露欲望的平台，与之争辩毫无意义。</p><p>互联网的真正价值在于知识、信息的共享。在互联网占领着我们大量清醒时间的时代，<strong>努力学习、善待他人、兼顾实际生活</strong>，简单地做到这三点，它就能让你线上线下的生活更美好，如果你能把你的个人品牌建立起来，让你的思想和努力规整、存档和共享，我愿意把这样的人尊称为<strong>“八季人”</strong>，也就是说，你等于能活两辈子，甚至传承更久。</p><span id="more"></span><h2 id="无处不在的个人品牌"><a href="#无处不在的个人品牌" class="headerlink" title="无处不在的个人品牌"></a>无处不在的个人品牌</h2><p>博客、播客、vlog、up主、粉丝、大V……这些词相信你每天都在打交道。不知不觉间，个人品牌如雨后春笋般出现在我们视野中。网红经济，大浪淘沙。最近五年是个人品牌数量快速发展的时期，今后十年将是金字招牌凸显的时候。个人品牌呈现以下三个特征：</p><h3 id="小众"><a href="#小众" class="headerlink" title="小众"></a>小众</h3><p>有了计算机技术后的世界是信息化的，数字化的，为了整合海量信息，如今它还呈现出了平台化的特征。当你在数字信息里兜兜转转，企图去寻找那些对自己有用的知识（比如有营养的视频）时，你会发现，搜寻、辨别、试错的成本往往超过你学到东西的价值。诚然，搜索引擎和平台的算法在帮助你降低这个成本，它们会把垃圾的东西过滤掉，但与此同时商业化已经把算法的公正性破坏（如SEO）。“小人”不见了，但我们必须甄别更多的“伪君子”。</p><p>近年来我屡屡发现，搜索引擎的第一位和平台上的“热门推荐”不等于高质量，更不等于对我有用，有时候小众的东西反而让你如获至宝，让你感叹这就是缘分。这些网站、博客就是个人品牌。<strong>不打广告，势单力薄</strong>，绝大多数的个人品牌肯定是小众的，但也绝对是内涵超过名气的。</p><h3 id="有用"><a href="#有用" class="headerlink" title="有用"></a>有用</h3><p>当你需要解决技术方面的问题，这些个人品牌就像快递的“最后一公里”，把官方的操作手册翻译、加工、整合，再送到你手中。<strong>负责任的个人品牌</strong>一定自己测试过，保证某种操作方式的有效性，并标明在何时何地是有效的。所以你只要关注他们，就能避免被大量无用的垃圾信息所骚扰。</p><p>虽然和官方相比，个人发布的东西不够权威，不够系统，文章像牢骚，技术如偏方，但随着个人实力的积累，牢骚越来越像离骚（指文学性提高），偏方也能自成一派，这样的东西并不比官方的质量差。并且，它真实、有效，不带包装，不加矫饰，这一点贯穿始终。</p><h3 id="朋友"><a href="#朋友" class="headerlink" title="朋友"></a>朋友</h3><p>个人品牌就像真正的朋友一样，只要你们趣味相投，只要人家高兴，他就会调用十八般武艺，用极大的热情和精力来帮助你解决问题，不计利益。这就像楼下招牌褪了色的小面馆，跟老板混熟了，多加两块肉一点问题没有，咸淡还更合你口味。试问，大饭店做得到吗，互联网大厂做得到吗？这是个人品牌感性的一面。</p><p>我们在写文章、做视频的时候，精心构思，有条有理；在评论的时候斟酌措辞，这些都体现出个人品牌理性的一面。互联网在我们之间蒙上了一层幕布，滤去了<strong>琐碎的真实，留下了有序的真意</strong>。</p><p>我们在泛滥的信息洪流中，一方面在不断寻求自己的定位、落脚点，或者，<strong>家</strong>，一方面在寻找有温度、说话好听、还能帮到我们的朋友。树立起自己的个人品牌就是家，而别人的个人品牌就是朋友。以个人品牌为媒介的交流，就像“君子之交淡如水”，我们的关系不近不远，我们的友谊地久天长。</p><h2 id="个人品牌的三个准则"><a href="#个人品牌的三个准则" class="headerlink" title="个人品牌的三个准则"></a>个人品牌的三个准则</h2><p>优质个人品牌的准则有以下三点：</p><h3 id="三观正，凭良心"><a href="#三观正，凭良心" class="headerlink" title="三观正，凭良心"></a>三观正，凭良心</h3><p>上文提到什么是一个负责任的个人品牌，负责只是个人品牌的道德中的一点。品行要端正，什么该写什么不该写，什么能写什么不能写，心里都有点数。</p><p><strong>换位思考</strong>。和做人一样，其实当好自己的产品经理，想一想观众看你的作品会有什么感受。概念太多，给一个官方说明，自己也复习一下；参考别人文章很多内容，按照知识共享协议，给一个跳转链接尊重一下？文字太多，插点美图、表情包、图表，整理一下自己的思路，也让读者喘口气，如何？这不是简简单单是优化的问题，你可能觉得我写给自己看别人爱看不看。但互联网就是为了分享的。</p><blockquote><p>请换位思考，在创作的时候秉持着分享精神</p></blockquote><h3 id="终身学习"><a href="#终身学习" class="headerlink" title="终身学习"></a>终身学习</h3><p>在学习、购物、计算机使用中遇到迷茫或者不畅时，第一时间想到<strong>大牛博客（或视频）、个人评测、佳软推荐</strong>，这样的人将越来越多。出于自古以来养成的习惯（以及被各大商业公司的反复欺骗），我们的信任更愿意给那些有血有肉的人，而不是冰冷的数据、平台和机构。个人品牌就是互联网上<strong>值得信赖的、有趣的、术业有专攻的</strong>朋友。实际生活中要找到这样的人何其不易啊。</p><p>要成为这样的人，成为互联网上对别人有用的人，终身学习，与时俱进是必然的要求。不仅在专业技术，还有<strong>文字的打磨、眼光的训练、信息的搜集与整合</strong>是需要一生精进的。</p><h3 id="理性互动"><a href="#理性互动" class="headerlink" title="理性互动"></a>理性互动</h3><p>不知不觉间，<strong>评论区</strong>成了某篇文章、视频或者产品质量的重要参考。用火眼金睛筛选评论区的<strong>水军、喷子</strong>，找到有用信息，对你来说可能易如反掌。评论区本该是科普和抒发感想的舞台，对“三季人”来说，却是比拼亲人数量的战场。</p><p>对个人品牌来说，切不可摆架子，不把人当人。<strong>积极、理性</strong>的互动，才能让你的个人品牌有温度有人情味，才能做到上文所说的“君子之交”。</p><h2 id="个人素质是个人品牌的基础"><a href="#个人素质是个人品牌的基础" class="headerlink" title="个人素质是个人品牌的基础"></a>个人素质是个人品牌的基础</h2><p>个人在实际生活中足够优秀，品牌才能足够响亮。你的硬实力，即知识、技术、能力将起决定性作用，而软实力，即包装（文笔、网页、特效、公关等）的作用也绝对不能小觑。以貌取人饱受诟病，但这是我们人类的本性，无可厚非。文如其人，相由心生的观念也有其道理。正视它，接受它，同时把软硬实力熔为一炉，才是当今个人品牌塑造的坦途。</p><p>对于增强硬实力，我们提倡终身学习，追逐前沿，创新创造；对于增强软实力，多阅读、勤思考、善沟通、懂设计显得尤为重要，一个优秀的个人品牌持有者，一定在努力做一个<strong>作者、读者、哲人、设计师和鉴赏家</strong>。</p><h2 id="建立个人品牌的意义"><a href="#建立个人品牌的意义" class="headerlink" title="建立个人品牌的意义"></a>建立个人品牌的意义</h2><p>生活已经不易，我还要这么累去打造个人品牌，意义何在？</p><ol><li>当做日记，能看到自己的成长历程，<strong>作为经历让自己反思，作为计划让自己行动</strong></li><li>当做<strong>梦和灵感</strong>一类事物的备忘</li><li>当做笔记，以加深记忆，<strong>梳理框架，深化细节</strong></li><li>以上三点都有<strong>分享和交流</strong>的意义</li><li>传承的意义：足够丰富的、有永恒价值的个人品牌将长久地活在网络中</li></ol><p>如今的互联网给了所有品牌凸显的机会，当你的个人品牌建立的那一刻起，你将不再是互联网海洋里的到处游走的水分子，而是成为了一块坚定的礁石，虽然依然渺小，但有了确定的坐标，有了出发点和归宿。通过努力，你将变得美丽多姿，鱼虾成群，不断壮大，也许终其一生你在体积上都比不过那些岛屿和大陆，但是你的色彩和温度无与伦比。如前文所述，今后十年，个人品牌的话语权会越来越大，足够优秀的个人品牌代代相传也是有可能的。</p><h2 id="行动起来吧"><a href="#行动起来吧" class="headerlink" title="行动起来吧"></a>行动起来吧</h2><p>说了这么多，到最后，信心和行动是最重要的。说是要制胜，要凸显，其实在起步阶段，大家抱着平常心，把这个过程看成平常的日记、随感、笔记就好，没人看给自己看也是很有意义的。无论现在处于什么水平，只要开始就不算晚。慢慢积累，保持谦卑。</p><p>以下是我整理的建立个人品牌的步骤：</p><ol><li><p>开始学习至少一样东西，无论什么，比如：</p><ul><li><p>任意一门你感兴趣的语言</p></li><li><p>任何领域的可以分享的、有价值的技术</p></li><li><p>任意一本可以分享的、有价值的书</p></li><li><p>你的一次出行，照片和游记</p></li></ul></li><li><p>关注已经成熟的吸引你的个人品牌，学习模仿。可以进一步看他们推荐的，扩展开去。</p></li><li><p>学习编程、web前端、视频剪辑、图案设计等等（仅供参考，要用啥学啥，用多深学多深）。这些还没学会，不是整天划水的借口。内容创作不能停下：</p><ul><li><p>比如建站前就可以用markdown在本地写起来，写写上述第1点提到的内容，整理整理第2点中那些成熟个人品牌，列个单子推荐给大家，也可以把视频剪辑这类技术学习的过程记录下来</p><p><img src="/2021/10/11/%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C%E7%9A%84%E5%BC%80%E5%A7%8B/images.png"></p></li><li><p>比如学习使用视频剪辑软件前，想法、素材、分镜、文案都可以准备起来。</p></li></ul></li><li><p>给自己取个名字，设计一个logo，制作水印、签名或者片头片尾</p></li><li><p>找个平台或者自己建站发布吧！</p></li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>2020年新春，我23岁了。我想，这已经不再是自我封闭，无所事事的年纪了。回顾过去，没啥好说的。和我的个人网站一样，让一切从零开始吧！</p><h3 id="2021年10月"><a href="#2021年10月" class="headerlink" title="2021年10月"></a>2021年10月</h3><p>回头整理资料，发现写得还可以，便想在博客上发布这篇宣言式的文章。当时的我真的像共产主义萌芽时的年轻人一样，崇尚着人性的高贵，充满理想主义气息。谁能料到，现在的我已经投身于研究大数据的洪流之中了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;楔子&quot;&gt;&lt;a href=&quot;#楔子&quot; class=&quot;headerlink&quot; title=&quot;楔子&quot;&gt;&lt;/a&gt;楔子&lt;/h2&gt;&lt;p&gt;昨天看曾仕强教授的演讲，讲了个&lt;strong&gt;三季人&lt;/strong&gt;的故事。就是说孔子的学生和一个路人争辩一年到底有几个季节，路人坚决认为是三个季节，孔子学生说明明是四个季节，两人吵得不可开交，只好请孔子来决断。孔子看了路人一眼就对学生说，一年是三个季节，你朝他磕个头承认错误吧。孔子的学生满怀不甘地磕了头，路人也高高兴兴地走了。时候，学生埋怨孔子为什么不坚持真理，孔子说：“你看那个家伙，衣服是绿的，就是只蚂蚱，活不过这个秋天，在他眼里，一年就是三季，你怎么争都不会有结果，还不如磕个头让他高高兴兴地离开。”在网络喷子和“杠精”横行的当下，这个故事颇有启发意义。&lt;/p&gt;
&lt;p&gt;事实上人和人的差别比人和蚂蚱都要大，当今网络空间里的&lt;strong&gt;“三季人”&lt;/strong&gt;我们见得太多了。逞口舌之快，开口就是祖宗十八代，自认为是龙吟虎啸，在别人眼里却不过是跳梁小丑。在他们的认知里，网络就是发泄情绪和暴露欲望的平台，与之争辩毫无意义。&lt;/p&gt;
&lt;p&gt;互联网的真正价值在于知识、信息的共享。在互联网占领着我们大量清醒时间的时代，&lt;strong&gt;努力学习、善待他人、兼顾实际生活&lt;/strong&gt;，简单地做到这三点，它就能让你线上线下的生活更美好，如果你能把你的个人品牌建立起来，让你的思想和努力规整、存档和共享，我愿意把这样的人尊称为&lt;strong&gt;“八季人”&lt;/strong&gt;，也就是说，你等于能活两辈子，甚至传承更久。&lt;/p&gt;</summary>
    
    
    
    <category term="freetime" scheme="http://example.com/categories/freetime/"/>
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>docker-入门</title>
    <link href="http://example.com/2021/09/24/docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/09/24/docker-%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-24T01:49:09.000Z</published>
    <updated>2022-10-09T08:44:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-入门"><a href="#docker-入门" class="headerlink" title="docker 入门"></a>docker 入门</h1><blockquote><p>Linux 容器不是模拟一个完整的操作系统，而是对进程的隔离，或者说，在正常进程外面套了一个保护层。</p></blockquote><p>相比虚拟机的优点：</p><ul><li><p>启动快</p></li><li><p>资源占用少</p></li><li><p>体积小</p></li></ul><blockquote><p>docker 是 Linux 容器的一种封装，提供简单易用的容器使用接口</p></blockquote><h2 id="docker-用途"><a href="#docker-用途" class="headerlink" title="docker 用途"></a>docker 用途</h2><ol><li><strong>提供一次性的环境</strong><br>本地测试他人的软件、持续集成的时候提供单元测试和构建的环境</li><li><strong>提供弹性的云服务</strong><br>动态扩容和缩容</li><li><strong>组建微服务架构</strong><br>一台机器跑多个服务</li></ol><span id="more"></span><h2 id="image-文件"><a href="#image-文件" class="headerlink" title="image 文件"></a>image 文件</h2><blockquote><p>Docker 把应用程序及其依赖，打包在 image 文件里。</p></blockquote><pre><code class="bash"># 列出本机的所有image文件docker image ls# 删除image文件docker image rm [imageName]# 导入镜像存储文件docker load</code></pre><p>从 image 文件生成容器</p><pre><code class="shell">docker container run -p 8000:3000 -it koa-demo /bin/bash# 如果加了CMD，就不能加/bin/bashdocker container run -p 8000:3000 -it koa-demo -p参数：容器的 3000 端口映射到本机的 8000 端口。-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</code></pre><h2 id="容器快照、镜像导入导出"><a href="#容器快照、镜像导入导出" class="headerlink" title="容器快照、镜像导入导出"></a>容器快照、镜像导入导出</h2><pre><code class="shell"># 单个容器当前状态docker export 7691a814370e &gt; ubuntu.tardocker import ubuntu.tar test/ubuntu:v1.0# 多镜像打包，包含历史记录docker save -o xxx.tar fedora busybox ...docker load -i xxx.tar</code></pre><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><blockquote><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong></p><p>关闭容器并不会删除容器文件，只是容器停止运行而已。</p></blockquote><pre><code class="bash"># 列出本机正在运行的容器docker container ls # 列出本机所有容器，包括终止运行的容器docker container ls --all# 删除容器文件docker container rm [containerID]</code></pre><h2 id="Dockerfile-制作-image"><a href="#Dockerfile-制作-image" class="headerlink" title="Dockerfile 制作 image"></a>Dockerfile 制作 image</h2><p>从一个基础镜像自定义制作一个镜像，以 koa-demos 为例</p><pre><code class="bash">git clone https://github.com/ruanyf/koa-demos.gitcd koa-demos</code></pre><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore">内容</a>。</p><pre><code class="bash">.gitnode_modulesnpm-debug.log</code></pre><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile">内容</a>。</p><pre><code class="bash">FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000CMD node demos/01.js</code></pre><p>上面代码一共五行，含义如下。</p><pre><code class="shell">- `FROM node:8.4`：该 image 文件继承官方的 node image，冒号表示标签，这里标签是`8.4`，即8.4版本的 node。- `COPY . /app`：将当前目录下的所有文件（除了`.dockerignore`排除的路径），都拷贝进入 image 文件的`/app`目录。- `WORKDIR /app`：指定接下来的工作路径为`/app`。- `RUN npm install`：在`/app`目录下，运行`npm install`命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。- `EXPOSE 3000`：将容器 3000 端口暴露出来， 允许外部连接这个端口。- `CMD node demos/01.js`:容器启动后自动执行node demos/01.js![image.png](16a02cdc42dd43f0tplv-t2oaga2asx-watermark.awebp)</code></pre><p>创建 image 文件，可以后续发布到官方仓库</p><pre><code class="shell">docker image build -t [newImageName] .docker image ls</code></pre><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><pre><code class="shell"># 启动容器，区别于docker container run的新建容器docker container start [containerID]# 用于进入一个正在运行的docker容器docker container exec -it [containerID] /bin/bash# 通过连接stdin，连接到容器内输入输出流，会在输入exit后终止docker进程# 运维时应用ctrl+p+q切换到后台docker attach [containerID] # 终止容器的运行，比docker container kill多发送了一个SIGTERM信号docker container stop [containerID]# 查看容器的IDdocker ps -adocker container ls# 查看容器长IDdocker inspect -f '{{.ID}}' 容器名# 查看容器所有信息docker inspect [containerID]# 宿主机文件放入docker，反之亦然docker cp 宿主机路径 [containerID]:容器内路径</code></pre><p><img src="/2021/09/24/docker-%E5%85%A5%E9%97%A8/16a02cdbf14142a0tplv-t2oaga2asx-watermark.awebp" alt="image.png"> </p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903815729119245">30 分钟快速入门 Docker 教程</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰的网络日志-Docker入门教程</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;docker-入门&quot;&gt;&lt;a href=&quot;#docker-入门&quot; class=&quot;headerlink&quot; title=&quot;docker 入门&quot;&gt;&lt;/a&gt;docker 入门&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Linux 容器不是模拟一个完整的操作系统，而是对进程的隔离，或者说，在正常进程外面套了一个保护层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相比虚拟机的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源占用少&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;体积小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;docker 是 Linux 容器的一种封装，提供简单易用的容器使用接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;docker-用途&quot;&gt;&lt;a href=&quot;#docker-用途&quot; class=&quot;headerlink&quot; title=&quot;docker 用途&quot;&gt;&lt;/a&gt;docker 用途&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提供一次性的环境&lt;/strong&gt;&lt;br&gt;本地测试他人的软件、持续集成的时候提供单元测试和构建的环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供弹性的云服务&lt;/strong&gt;&lt;br&gt;动态扩容和缩容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组建微服务架构&lt;/strong&gt;&lt;br&gt;一台机器跑多个服务&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>诗解</title>
    <link href="http://example.com/2021/09/14/%E8%AF%97%E8%A7%A3/"/>
    <id>http://example.com/2021/09/14/%E8%AF%97%E8%A7%A3/</id>
    <published>2021-09-14T11:22:50.000Z</published>
    <updated>2022-10-09T08:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="后续（初次出去的后续，诗名比较随意）"><a href="#后续（初次出去的后续，诗名比较随意）" class="headerlink" title="后续（初次出去的后续，诗名比较随意）"></a>后续（初次出去的后续，诗名比较随意）</h1><p>亲爱的（直抒胸臆）</p><p>别说话，别思考，别多想（指qtt纯真的天性，不会太多思考人情世故，另外带些笔者的暧昧）</p><p>静谧的夜，丛林和虫鸣（指到了锦绣村没进去）</p><p>不必牵手，只是靠近</p><p>你的心跳，我的呼吸，互诉孤独的忧伤（指两人以前喜欢单独行动，尝过自由和寂寞）</p><p>不必犹豫，只是相视</p><p>你眼中的星辰啊，倒映在我深黑色的眼底（qtt眼睛很好看，笔者眼睛很深邃，也有关于两人以前接触的世界不同，思维方式不同的暗示）</p><span id="more"></span><p>亲爱的</p><p>去争夺，去绽放，去张扬（与前段相反，分开后各自独立奋斗）</p><p>霓虹灯管，吉他和嘶吼（旧天堂书店常邀请乐队）</p><p>不必懊悔，只管尝试（笔者推崇多尝试，自己动手的人生态度）</p><p>步履坚强，烟火如香（指qtt很能走路，并且带着平常人家的烟火气息，笔者觉得很香，头发也挺香）</p><p>不惧风浪，鼓帆航行（指看海的时候，qtt说想在远海的船上漂着）</p><p>海风卷走两岸的忧伤（香港深圳两岸）</p><p>一起听潮，多么宁静的声响（海潮起伏，qtt吹着海风，笔者看着她的背影，找到了心灵的安宁）</p><blockquote><p>gsb 赠 qtt 作于2021.08.01</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;后续（初次出去的后续，诗名比较随意）&quot;&gt;&lt;a href=&quot;#后续（初次出去的后续，诗名比较随意）&quot; class=&quot;headerlink&quot; title=&quot;后续（初次出去的后续，诗名比较随意）&quot;&gt;&lt;/a&gt;后续（初次出去的后续，诗名比较随意）&lt;/h1&gt;&lt;p&gt;亲爱的（直抒胸臆）&lt;/p&gt;
&lt;p&gt;别说话，别思考，别多想（指qtt纯真的天性，不会太多思考人情世故，另外带些笔者的暧昧）&lt;/p&gt;
&lt;p&gt;静谧的夜，丛林和虫鸣（指到了锦绣村没进去）&lt;/p&gt;
&lt;p&gt;不必牵手，只是靠近&lt;/p&gt;
&lt;p&gt;你的心跳，我的呼吸，互诉孤独的忧伤（指两人以前喜欢单独行动，尝过自由和寂寞）&lt;/p&gt;
&lt;p&gt;不必犹豫，只是相视&lt;/p&gt;
&lt;p&gt;你眼中的星辰啊，倒映在我深黑色的眼底（qtt眼睛很好看，笔者眼睛很深邃，也有关于两人以前接触的世界不同，思维方式不同的暗示）&lt;/p&gt;</summary>
    
    
    
    
    <category term="life" scheme="http://example.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>数据库进阶</title>
    <link href="http://example.com/2021/07/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2021/07/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/</id>
    <published>2021-07-11T13:36:39.000Z</published>
    <updated>2022-10-09T08:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><h2 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h2><pre><code class="sql">-- 子查询是结果是一个值select * from students where age &gt; (select avg(age) from students);</code></pre><h2 id="列级子查询"><a href="#列级子查询" class="headerlink" title="列级子查询"></a>列级子查询</h2><blockquote><p>返回的结果是一列(一列多行)</p></blockquote><pre><code class="sql">select 列名 from 表名 where id in (结果是一列的sql语句);</code></pre><h2 id="行级子查询"><a href="#行级子查询" class="headerlink" title="行级子查询"></a>行级子查询</h2><blockquote><p>和标量差不多，区别是子查询结果是一行多列</p></blockquote><pre><code class="sql"> select * from students from students where (height,age) = (select max(height),max(age) from students)</code></pre><span id="more"></span><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><blockquote><p>使用后形状不变，类似于pandas里的transform()</p></blockquote><pre><code class="sql">select *,rank() over (partition by 分组依据列名 order by 排序依据列名 desc) as 新的排名列名 from 表名;</code></pre><p><img src="/2021/07/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E9%98%B6/UVwajev8FuK9QzW.jpg"></p><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><ul><li><p>脏读、脏写、不可重复度、幻读</p></li><li><p>mysql默认等级为可重复读</p></li></ul><pre><code class="sql">-- 查看select @@tx_isolationselect @@global.tx_isolation-- 修改set session transaction isolation level ...-- read uncommitted-- read committed-- repeatable read(default)-- serializable</code></pre><p><a href="https://elsef.com/2018/11/28/%E7%BB%8F%E5%B8%B8%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84MySQL%E4%B8%AD%E5%AF%B9REPEATABLE-READ/">幻读的详细解释</a></p><h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><pre><code class="sql">UPDATE tablename SET ...=... WHERE ...-- sql注入where id=1 or 1=1--拿到整个数据库-- 解决方法：传参-- python里设定规则，findname读到空格结束，过滤空格后的内容-- 单独识别or/and，后面的内容放到列表的下一个元素para=[findname]</code></pre><h1 id="索引与效率"><a href="#索引与效率" class="headerlink" title="索引与效率"></a>索引与效率</h1><h2 id="索引类别：聚集索引、唯一索引"><a href="#索引类别：聚集索引、唯一索引" class="headerlink" title="索引类别：聚集索引、唯一索引"></a>索引类别：聚集索引、唯一索引</h2><blockquote><p>主键创建时默认是聚集索引</p></blockquote><ul><li><p><strong>聚集索引：</strong>一张表只能有一列，直接存放B+树叶子结点的地址。非聚集索引存放聚集索引的地址。</p></li><li><p><strong>唯一索引：</strong>不重复，但可以为null。</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://www.cnblogs.com/xrq730/p/8446246.html">https://www.cnblogs.com/xrq730/p/8446246.html</a></p><p><strong>char 和 varchar</strong>:</p><p>对于MyISAM表，推荐CHAR类型；对于InnoDB表，推荐VARCHAR类型</p><h1 id="MySql存储结构是B-树"><a href="#MySql存储结构是B-树" class="headerlink" title="MySql存储结构是B+树"></a>MySql存储结构是B+树</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;子查询&quot;&gt;&lt;a href=&quot;#子查询&quot; class=&quot;headerlink&quot; title=&quot;子查询&quot;&gt;&lt;/a&gt;子查询&lt;/h1&gt;&lt;h2 id=&quot;标量子查询&quot;&gt;&lt;a href=&quot;#标量子查询&quot; class=&quot;headerlink&quot; title=&quot;标量子查询&quot;&gt;&lt;/a&gt;标量子查询&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;-- 子查询是结果是一个值
select * from students where age &amp;gt; (select avg(age) from students);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;列级子查询&quot;&gt;&lt;a href=&quot;#列级子查询&quot; class=&quot;headerlink&quot; title=&quot;列级子查询&quot;&gt;&lt;/a&gt;列级子查询&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;返回的结果是一列(一列多行)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;select 列名 from 表名 where id in (结果是一列的sql语句);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;行级子查询&quot;&gt;&lt;a href=&quot;#行级子查询&quot; class=&quot;headerlink&quot; title=&quot;行级子查询&quot;&gt;&lt;/a&gt;行级子查询&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;和标量差不多，区别是子查询结果是一行多列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt; select * from students from students where (height,age) = (select max(height),max(age) from students)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库入门</title>
    <link href="http://example.com/2021/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/07/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/</id>
    <published>2021-07-04T14:10:48.000Z</published>
    <updated>2023-02-13T05:45:22.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><p><strong>注：</strong><code>' ' 指数字或字符串</code></p><blockquote><p>查询比较重要，占业务的绝大多数</p></blockquote><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><pre><code class="sql">SELECT 字段 FROM 表;SELECT * FROM 表;SELECT DISTINCT 字段 FROM 表;</code></pre><h4 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a>TOP</h4><pre><code class="sql">SELECT TOP 记录数 * FROM 表;SELECT TOP 百分数 PERSENT FROM 表;</code></pre><span id="more"></span><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><pre><code class="sql">SELECT * FROM 表 WHERE 字段+运算符+' ';SELECT * FROM 表 WHERE (字段A=' ' OR 字段A=' ') AND 列B=' ';SELECT * FROM 表 WHERE 字段A&lt;&gt;' ' OR 字段A is null;SELECT * FROM 表 WHERE 字段A&gt;ALL(… and 字段A is not NULL);SELECT * FROM 表 WHERE 字段 IN (' ',' ');</code></pre><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=、&lt;&gt;</td><td>等于、不等于</td></tr><tr><td>&lt;、&gt;、&lt;=、&gt;=</td><td></td></tr><tr><td>(NOT)BETWEEN…AND…</td><td>(不)在某个范围内</td></tr><tr><td>(NOT)LIKE</td><td>(不)匹配某种模式</td></tr></tbody></table><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><pre><code class="sql">SELECT * FROM 表 WHERE 字段 LIKE '%_[][!]';SELECT * FROM 表 WHERE 字段 NOT LIKE '%';</code></pre><h4 id="AS-x2F"><a href="#AS-x2F" class="headerlink" title="AS/@"></a>AS/@</h4><pre><code class="sql">-- 变量名SET @X=' '-- 表别名SELECT 别名.字段 FROM 表 AS 别名;-- 字段别名SELECT 字段 AS 别名 FROM 表;</code></pre><h4 id="INTO"><a href="#INTO" class="headerlink" title="INTO"></a>INTO</h4><pre><code class="sql">SELECT * INTO 新表 FROM 表;SELECT * INTO 新表 IN 数据库 FROM 表;</code></pre><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><pre><code class="sql">SELECT * FROM 表 ORDER BY 字段SELECT * FROM 表 ORDER BY 字段 DESC;SELECT * FROM 表 ORDER BY 字段A, 字段B;-- 跳过第一行，取接下来的三行SELECT * FROM 表 ORDER BY 字段 LIMIT 1,3;</code></pre><h3 id="INSERT-INTO"><a href="#INSERT-INTO" class="headerlink" title="INSERT INTO"></a>INSERT INTO</h3><pre><code class="sql">INSERT INTO 表 (字段A, 字段B) VALUES (值1, 值2);</code></pre><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><pre><code class="sql">UPDATE 表 SET 字段=' ' WHERE 字段=' ';</code></pre><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><pre><code class="sql">DELETE FROM 表 WHERE 字段=' ';DELETE FROM 表;-- 主键继承之前的序号DELETE * FROM 表;-- 主键重新开始TRUNCATE TABLE 表;</code></pre><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><pre><code class="sql">SELECT 聚合函数(待统计的字段) FROM 表 GROUP BY 存在重复的字段;</code></pre><table><thead><tr><th>函数</th><th>描述</th><th>其他</th></tr></thead><tbody><tr><td>count()</td><td>条数</td><td>不计入null 值</td></tr><tr><td>sum()</td><td>求和</td><td>不计入null 值</td></tr><tr><td>max()</td><td>最大值</td><td>时间字段代表最近最晚的时间</td></tr><tr><td>min()</td><td>最小值</td><td>时间字段代表最早的时间</td></tr><tr><td>avg()</td><td>平均值</td><td>不计入null 值</td></tr></tbody></table><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><pre><code class="sql">SELECT 字段 FROM 左表 JOIN 右表 ON 左表.字段=右表.字段;LEFT JOIN/RIGHT JOIN/FULL JOIN</code></pre><h3 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION(ALL)"></a>UNION(ALL)</h3><ul><li>列名不一致时，以第一条sql语句的列名对齐</li><li>使用union查询会将重复的行过滤掉，UNION ALL保留重复行</li></ul><pre><code class="sql">SELECT ...UNIONSELECT ...;</code></pre><h3 id="VIEW"><a href="#VIEW" class="headerlink" title="VIEW"></a>VIEW</h3><pre><code class="sql">CREATE VIEW 视图 AS SELECT 字段 FROM 表 WHERE ...;SHOW CREATE TABLE 视图/表;CREATE OR REPLACE VIEW 视图 AS SELECT 字段 FROM 表 WHERE ...;DROP VIEW 视图;</code></pre><h3 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h3><pre><code class="sql">CREATE INDEX 索引 ON 表(字段(LENGTH));CREATE UNIQUE INDEX 索引 ON 表(字段(LENGTH));ALTER TABLE 表 ADD 索引类 索引名 (字段A(LENGTH), 字段B(LENGTH));SHOW INDEX FROM 表;ALTER TABLE 表 DROP INDEX 索引名</code></pre><table><thead><tr><th>索引类</th><th align="left">描述</th></tr></thead><tbody><tr><td>INDEX</td><td align="left">普通索引</td></tr><tr><td>UNIQUE</td><td align="left">唯一索引</td></tr><tr><td>FULLTEXT</td><td align="left">全文索引(MyISAM)</td></tr><tr><td>组合索引</td><td align="left">最左前缀原则</td></tr></tbody></table><h3 id="CREATE-DATABASE"><a href="#CREATE-DATABASE" class="headerlink" title="CREATE DATABASE"></a>CREATE DATABASE</h3><pre><code class="sql">CREATE DATABASE IF NOT EXISTS 数据库 default character set utf8mb4 collate utf8mb4_unicode_ci;SHOW DATABASES;DROP DATABASE 数据库;</code></pre><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><pre><code class="sql">CREATE TABLE 表 (    字段A 数据类型 NOT NULL DEFAULT='',    字段B 数据类型,PRIMARY KEY AUTO_INCREMENT,     CONSTRAINT 约束名 约束类 (字段A, 字段B),    索引类 索引名 (字段(LENGTH)))AUTO_INCREMENT=1;SHOW TABLES;DROP TABLE 表;</code></pre><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">integer(size)<br>int(size)<br>smallint(size)<br>tinyint(size)</td><td align="left">仅容纳整数。在括号内规定数字的最大位数。</td></tr><tr><td align="left">decimal(size,d)<br>numeric(size,d)</td><td align="left">容纳带有小数的数字。”size” 规定数字的最大位数。”d” 规定小数点右侧的最大位数。</td></tr><tr><td align="left">char(size)</td><td align="left">容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度。</td></tr><tr><td align="left">varchar(size)</td><td align="left">容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度。</td></tr><tr><td align="left">date(yyyymmdd)</td><td align="left">容纳日期。</td></tr></tbody></table><table><thead><tr><th>约束</th><th>描述</th></tr></thead><tbody><tr><td>NOT NULL</td><td>防止某字段为NULL</td></tr><tr><td>UNIQUE</td><td>防止某字段重复值</td></tr><tr><td>PRIMARY KEY AUTO_INCREMENT</td><td>设为主键，防NULL防重复，自增</td></tr><tr><td>FOREIGN KEY…REFERENCES…</td><td>设为另一表的主键</td></tr><tr><td>DEFAULT</td><td>设置默认值</td></tr><tr><td>CHECK(OPERATOR/AND/OR)</td><td>自定义约束</td></tr></tbody></table><h3 id="ALTER-TABLE"><a href="#ALTER-TABLE" class="headerlink" title="ALTER TABLE"></a>ALTER TABLE</h3><h4 id="更改约束"><a href="#更改约束" class="headerlink" title="更改约束"></a>更改约束</h4><pre><code class="sql">-- NOT NULL的更改ALTER TABLE 表 MODIFY COLUMN 字段 数据类型;ALTER TABLE 表 MODIFY COLUMN 字段 数据类型 NOT NULL;-- DEFAULT的更改ALTER TABLE 表 ALTER 字段 SET DEFAULT ' ';ALTER TABLE 表 ALTER 字段 DROP DEFAULT;-- 其他约束的更改ALTER TABLE 表 ADD 约束类(字段A, 字段B);ALTER TABLE 表 ADD CONSTRAINT 约束名 约束类 (字段A, 字段B);ALTER TABLE 表 DROP CONSTRAINT 约束名;</code></pre><h4 id="添加列-x2F-更改数据类型"><a href="#添加列-x2F-更改数据类型" class="headerlink" title="添加列/更改数据类型"></a>添加列/更改数据类型</h4><pre><code class="sql">ALTER TABLE 表 ADD 新字段 数据类型;ALTER TABLE 表 MODIFY COLUMN 字段 新数据类型;ALTER TABLE 表 CHANGE COLUMN 字段 新字段名 新数据类型;ALTER TABLE 表 DROP COLUMN 字段;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SQL语法&quot;&gt;&lt;a href=&quot;#SQL语法&quot; class=&quot;headerlink&quot; title=&quot;SQL语法&quot;&gt;&lt;/a&gt;SQL语法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;code&gt;&#39; &#39; 指数字或字符串&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查询比较重要，占业务的绝大多数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;SELECT&quot;&gt;&lt;a href=&quot;#SELECT&quot; class=&quot;headerlink&quot; title=&quot;SELECT&quot;&gt;&lt;/a&gt;SELECT&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;SELECT 字段 FROM 表;
SELECT * FROM 表;
SELECT DISTINCT 字段 FROM 表;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;TOP&quot;&gt;&lt;a href=&quot;#TOP&quot; class=&quot;headerlink&quot; title=&quot;TOP&quot;&gt;&lt;/a&gt;TOP&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;SELECT TOP 记录数 * FROM 表;
SELECT TOP 百分数 PERSENT FROM 表;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>大家的日语初级上</title>
    <link href="http://example.com/2021/07/04/%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7%E4%B8%8A/"/>
    <id>http://example.com/2021/07/04/%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%97%A5%E8%AF%AD%E5%88%9D%E7%BA%A7%E4%B8%8A/</id>
    <published>2021-07-04T14:09:35.000Z</published>
    <updated>2021-07-05T14:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="皆さんの日本語-初級上"><a href="#皆さんの日本語-初級上" class="headerlink" title="皆さんの日本語　初級上"></a>皆さんの日本語　初級上</h1><blockquote><p>覚えにくい、より難しい知識</p></blockquote><h2 id="単語"><a href="#単語" class="headerlink" title="単語"></a>単語</h2><p>教室　きょうしつ</p><p>授業　じゅぎょう</p><p>橋／箸　はし</p><p>平仮名　ひえあがな</p><p>片仮名　カタカナ</p><p>手伝う　てつだう</p><p>買い物する</p><p>沖縄　おきなわ</p><span id="more"></span><p>市役所　しやくしょ</p><p>役に立つ　やくにたつ</p><p>間　あいだ</p><p>集める　あつめる</p><p>意見　いけん</p><p>田舎　いなか</p><p>要る　いる</p><p>後ろ　うしろ</p><p>上着　うわぎ</p><p>動く　うごく</p><p>家内＝妻</p><p>音楽　おんがく</p><p>確認　かくにん</p><p>角　かど</p><p>生活　せいかつ</p><p>洗濯　せんたく</p><p>自動販売機　じどうはんばいき</p><p>地図　ちず</p><p>地球　ちきゅう</p><p>地下鉄　ちかてつ</p><p>調子　ちょうし　</p><p>だんだん増（ふ）える</p><h3 id="外来語"><a href="#外来語" class="headerlink" title="外来語"></a>外来語</h3><p>インターネットInternet</p><p>エスカレータ　escalator</p><h3 id="数词特辑"><a href="#数词特辑" class="headerlink" title="数词特辑"></a>数词特辑</h3><p>0.1れいてんいち　1/10じゅうぶんのいち</p><p>三百さんびゃく　六百　ろっぴゃく　八百　はっぴゃく</p><p>三千　さんぜん　八千　はっせん</p><p>四時　よじ　九時　くじ</p><p>九分　きゅうふん　十分　じゅっぷん　</p><p>七時七分　しちじななふん　</p><p>月曜日　げつようび</p><p>九月九日　くがつここのか　四月十四日　しがつじゅうよっか</p><table><thead><tr><th>順番</th><th>いつ</th><th>いくつ</th></tr></thead><tbody><tr><td>1</td><td>ついたち</td><td>ひとつ</td></tr><tr><td>2</td><td>ふつか</td><td>ふたつ</td></tr><tr><td>3</td><td>みっか</td><td>みっつ</td></tr><tr><td>4</td><td>よっか</td><td>よっつ</td></tr><tr><td>5</td><td>いつか</td><td>いつつ</td></tr><tr><td>6</td><td>むいか</td><td>むいつ</td></tr><tr><td>7</td><td>なのか</td><td>ななつ</td></tr><tr><td>8</td><td>ようか</td><td>やっつ</td></tr><tr><td>9</td><td>ここのか</td><td>ここのつ</td></tr><tr><td>10</td><td>とおか</td><td>とお</td></tr></tbody></table><h3 id="助数詞特辑"><a href="#助数詞特辑" class="headerlink" title="助数詞特辑"></a>助数詞特辑</h3><h4 id="月不用“间”，谁来拯救它？"><a href="#月不用“间”，谁来拯救它？" class="headerlink" title="月不用“间”，谁来拯救它？"></a>月不用“间”，谁来拯救它？</h4><p>三ヶ月　三か月　三箇月</p><p><a href="https://landgather.com/month">https://landgather.com/month</a></p><h4 id="通用量词"><a href="#通用量词" class="headerlink" title="通用量词"></a>通用量词</h4><p>「匹」：是指小型動物，如「犬、猫、魚、蚊」等，皆用「一匹、二匹、三匹」。<br>「頭」：則是大型動物，如「馬、牛、象」等，皆用「一頭、二頭、三頭」。<br>「枚」：指扁扁的東西，如「紙、封筒、はがき」等，皆用「一枚、二枚」。<br>「冊」：是書籍一冊冊的意思，如「本、雑誌」等，皆用「一冊、二冊」。<br>「本」：用於量詞時並不是書的意思，而是「支」或「條」的意思，用於長條狀的東西，如「鉛筆、箸、ネクタイ」等，皆用「一本、二本、三本」來表示。</p><p><a href="https://www.sigure.tw/comprehensive-learning/knowledge/465-japanese-counter-word">時雨の町</a></p><h4 id="その他"><a href="#その他" class="headerlink" title="その他"></a>その他</h4><p>其他还有许多常用的单位词，但用法较单纯，不容易混淆，简单条列如下:</p><p>番（ばん） “第～”计算顺序。</p><p>台（だい） “～台”计算交通工具及电器用品。</p><p>歳（さい） ～岁 年龄</p><p>着（ちゃく） ～件 衣服（衬衫、T恤用“枚”）</p><p>回（かい） ～次 频率</p><p><strong>足（そく） ～双 鞋子跟袜子</strong></p><p><strong>軒（けん） ～间 房屋</strong></p><p>階（かい） ～楼 楼层</p><p>位（い） 第～名 名次</p><p>円（えん） ～日元 货币</p><p>億（おく） ～亿</p><p>課（か） 课程；科（工作单位，机构）</p><p>回（かい） 次数</p><p>画（かく） 笔画</p><p>株（かぶ） 股票；有根植物</p><p>カロリー 卡路里</p><p>巻（かん） 丛书；胶卷</p><p>期（き） 定期毕业班级</p><p>級（きゅう） 等级</p><p>行（ぎょう） 成行的字</p><p>曲（きょく） 歌曲、音乐</p><p>局（きょく） 象棋等棋盘上进行的比赛</p><p>切れ（きれ） 切下的东西</p><p>キロ 千克</p><p>句（く） 文章、诗歌、俳句等</p><p>組（くみ） 班级、班组</p><p>桁（けた） [数]位数</p><p>件（けん） 事情</p><p>戸（こ） 家庭</p><p>校（こう） 校正；学校</p><p>号（ごう） 铅字大小；较小的法律条文；杂志等</p><p>歳（さい） 年龄</p><p>冊（さつ） 书籍、杂志等</p><p>字（じ） 文字</p><p>時（じ） 时刻</p><p>次（じ） 回数、次数</p><p>時間（じかん） 时间单位</p><p>室（しつ） 房间</p><p>種（しゅ） 种类</p><p>首（しゅ） 歌曲、诗歌</p><p>週（しゅう） 时间单位</p><p>周（しゅう） 圈数</p><p>重（じゅう） 层数</p><p>周年（しゅうねん） 周年</p><p>種類（しゅるい） 种类</p><p>章（しょう） 诗歌、文章</p><p>畳（じょう） 房屋面积</p><p>錠（じょう） 药片</p><p>筋（すじ） 细长东西</p><p>隻（せき） 船舶；鸟类</p><p>銭（せん） 货币</p><p>膳（ぜん） 饭食；筷子</p><p>センチ 长度单位</p><p>層（そう） 层数</p><p>艘（そう） 船只</p><p>揃い（そろい） 手套、服装等</p><p>体（たい） 雕像等</p><p><strong>台（だい） 汽车、自行车、机器等能运转的东西</strong></p><p>代（だい） 年代、年龄代</p><p>題（だい） 问题、试题等</p><p>度（たび） 次数</p><p>段（だん） 台阶</p><p><strong>着（ちゃく）衣服</strong></p><p>町（ちょう） 城镇、街道</p><p>通（つう） 书信、电话、电报等</p><p>粒（つぶ） 颗粒状物体</p><p>坪（つぼ） 面积单位</p><p>つまみ 粉末、小颗粒状物</p><p>点（てん） 分数、得分</p><p>度（ど） 温度、角度、经纬度、眼镜度数、次数</p><p>等（とう） 级别</p><p>とおり 种类</p><p>所（ところ） 地方</p><p>年（ねん） 年数</p><p>パーセント 百分比</p><p>杯（はい） 茶、咖啡、酒等饮料</p><p>倍（ばい） 倍数</p><p>拍（はく） 音乐、音节</p><p>泊（はく） 住宿时间</p><p>箱（はこ） 盒装物品</p><p>発（はつ） 子弹、炮弹、焰火等</p><p>班（はん） 组、班级</p><p>番（ばん） 次序</p><p>晩（ばん） ～晚</p><p>尾（び） ～条鱼</p><p>秒（びょう） 时间单位；时刻</p><p>部（ぶ） 书籍、文件等</p><p>分（ぶ） 温度单位“度”等的十分之一</p><p>歩（ほ） 路程</p><p>本（ほん） 树木、笔、裤子等各种细长的东西；录音带、录像带等</p><p>幕（まく） 戏剧等</p><p>い一轮</p><p>名（めい） 人</p><p>メートル 长度单位</p><p>面（めん） 报纸版面、镜子、琴、棋盘等</p><p>夜（や） 晚上</p><p>両（りょう） 车箱、车辆</p><p>輪（りん） 花</p><p>列（れつ） 队列</p><p><strong>羽（わ） 鸟类、兔子</strong></p><p>割（わり） 十分之一</p><p><a href="https://zhuanlan.zhihu.com/p/21559633">https://zhuanlan.zhihu.com/p/21559633</a></p><h3 id="扩展单词（教辅）"><a href="#扩展单词（教辅）" class="headerlink" title="扩展单词（教辅）"></a>扩展单词（教辅）</h3><h4 id="国"><a href="#国" class="headerlink" title="国"></a>国</h4><p>アラビア　</p><p>エジプト　Egypt</p><p>ベトナム　Vietnam</p><h4 id="名前"><a href="#名前" class="headerlink" title="名前"></a>名前</h4><p>渡辺　わたなべ</p><p>伊藤　いとう</p><p>小林こばやし　林　はやし</p><p>井上　いのうえ　上杉　うえすぎ</p><p>清水　しみず</p><h4 id="デパート"><a href="#デパート" class="headerlink" title="デパート"></a>デパート</h4><p>催し物会場もよおしもの会場</p><p>おもちゃ　</p><p>電化製品　でんかせいひん</p><p>家具　かぐ</p><p>文房具　ぶんぼうぐ</p><p>食器　しょっき　お膳　おぜん</p><p>紳士服　しんしふく　婦人服　ふじんふく</p><p>駐車場　ちゅうしゃじょう</p><p>化粧品けしょうひん</p><p>アクセサリー　accessory<code>饰品</code></p><h4 id="電話・手紙"><a href="#電話・手紙" class="headerlink" title="電話・手紙"></a>電話・手紙</h4><p>警察署　けいさつしょ</p><p>消防署　しょうぼうしょ</p><h4 id="祝祭日-しゅくさいじつ-祝日"><a href="#祝祭日-しゅくさいじつ-祝日" class="headerlink" title="祝祭日　しゅくさいじつ　祝日"></a>祝祭日　しゅくさいじつ　祝日</h4><p>勤労感謝の日　</p><p>文化の日　</p><p>体育の日　たいいくのひ</p><p>憲法記念日　けんぽうきねんび</p><h4 id="食べ物"><a href="#食べ物" class="headerlink" title="食べ物"></a>食べ物</h4><h5 id="野菜"><a href="#野菜" class="headerlink" title="野菜"></a>野菜</h5><p>きゅうり　<code>黄瓜</code></p><p>豆　まめ</p><p>大根　だいこん</p><p>レタス　lettuce</p><p>にんじん<code>胡萝卜</code> </p><p>葱　ねぎ</p><h5 id="果物-くだもの"><a href="#果物-くだもの" class="headerlink" title="果物　くだもの"></a>果物　くだもの</h5><p>いちご<code>草莓</code> </p><p>桃　もも</p><p>西瓜　すいか</p><p>葡萄　ぶどう</p><p>梨　なし</p><p>柿　かき</p><p>みかん　蜜柑　</p><h5 id="肉-にく"><a href="#肉-にく" class="headerlink" title="肉　にく"></a>肉　にく</h5><p>牛肉　ぎゅうにく</p><p>豚肉　ぶたにく</p><p>ソーセージ　sausage</p><p>ハム　ham</p><h5 id="魚介類-ぎょかいるい"><a href="#魚介類-ぎょかいるい" class="headerlink" title="魚介類　ぎょかいるい"></a>魚介類　ぎょかいるい</h5><p>あじ<code>竹荚鱼</code></p><p>いわし<code>沙丁鱼</code></p><p>さば<code>青花鱼</code></p><p>さんま秋刀鱼</p><p>さけ<code>鲑鱼</code></p><p>まぐろ<code>金枪鱼</code></p><p>たい<code>鲷鱼</code></p><p>たら<code>鳕鱼</code></p><p>かに<code>蟹</code></p><p>いか<code>乌贼</code></p><p>たこ<code>章鱼</code></p><h4 id="家族"><a href="#家族" class="headerlink" title="家族"></a>家族</h4><p>妻　つま</p><p>夫　おっと</p><p>夫婦　ふうふ</p><p>奥さん　おくさん</p><p>ご主人　ごしゅじん</p><p>お子さん　おこさん</p><h4 id="音楽-おんがく"><a href="#音楽-おんがく" class="headerlink" title="音楽　おんがく"></a>音楽　おんがく</h4><p>ポップス　pops</p><p>ロックrock</p><p>ジャズjazz</p><p>ラテンlatin</p><p>クラシックclassic</p><p>民謡　みんよう</p><p>演歌　えんか</p><p>ミュージカルmusical</p><p>オペラopera</p><h4 id="映画"><a href="#映画" class="headerlink" title="映画"></a>映画</h4><p>ホラーhorror</p><p>ドキュメンタリーdocumentary</p><p>ミステリーmystery</p><p>文芸ぶんげい</p><p>アクションaction</p><p>喜劇　きげき</p><h4 id="スポーツ"><a href="#スポーツ" class="headerlink" title="スポーツ"></a>スポーツ</h4><p>ソフトボールvolleyball</p><p>ラグビーrugby</p><p>バスケットボールbasketball</p><p>卓球たっきゅう</p><p>水泳　すいえい</p><p>ボウリングbowling</p><h4 id="家の中"><a href="#家の中" class="headerlink" title="家の中"></a>家の中</h4><p>玄関げんかん</p><p>廊下　ろうか</p><p>風呂場　ふろば</p><p>洗面所　せんめんじょ</p><p>台所　だいどころ</p><p>居間　いま</p><p>寝室　しんしつ　部屋　へや</p><p>ベランダ　veranda<code>阳台</code></p><h4 id="メニュー"><a href="#メニュー" class="headerlink" title="メニュー"></a>メニュー</h4><p>定食</p><p>天丼てんどん</p><p>親子丼　おやこどん</p><p>野菜炒め　やさいいため</p><p>焼きそば　やきそば</p><p>焼肉　やきにく</p><p>漬物　つけもの</p><p>みそ汁　みそしる</p><p>うどん　</p><p>ハンバーグhamburg</p><p>ハンバーガーhamburger</p><p>サラダsalad </p><p>コロッケ==法==<code>可乐饼</code></p><p>フライドチキンfrid chicken</p><p>サンドイッチsandwich</p><p>トーストtoast</p><p>ココアcocoa</p><h3 id="まつりと名所"><a href="#まつりと名所" class="headerlink" title="まつりと名所"></a>まつりと名所</h3><p>奈良　東大寺・大仏（ぶつ）</p><p>東京　神田祭り</p><p>大阪　天神祭</p><p>京都　祇園祭</p><p>広島　原爆ドーム</p><h4 id="町の中"><a href="#町の中" class="headerlink" title="町の中"></a>町の中</h4><p>博物館　はくぶつかん</p><p>植物園　しょくぶつえん</p><p>遊園地　ゆうえんち</p><p>教会　きょうかい</p><p>モスクmosque<code>清真寺</code></p><p>大使館　たいしかん　外交官　がいこうかん</p><p>入国管理局　にゅうこくかんりきょく</p><p>交番　こうばん</p><p>高校　こうこう</p><p>八百屋　やおや</p><h4 id="駅"><a href="#駅" class="headerlink" title="駅"></a>駅</h4><p>切符売り場　きっぷうりば</p><p>自動券売機　じどうけんばいき　自動販売機　じどうはんばいき</p><p>精算機せいさんき　算盤　そろばん</p><p>改札口　かいさつぐち<code>验票口</code></p><p>中央口　ちゅうおうぐち</p><p>特急　とっきゅう</p><p>急行　きゅうこう</p><p>快速　かいそく</p><p>準急　じゅんきゅう</p><p>普通　ふつう</p><p>時刻表　じこくひょう</p><p>定期券　ていきけん</p><p>回数券　かいすうけん</p><p>片道　かたみち<code>单程票</code></p><p>往復　おうふく</p><p>バス停　ばすてい</p><p>ホーム　<code>站台</code>platform</p><h4 id="職業-しょくぎょう"><a href="#職業-しょくぎょう" class="headerlink" title="職業　しょくぎょう"></a>職業　しょくぎょう</h4><p>公務員　こうむいん</p><p>調理師　ちょうりし</p><p>理容師　りようし</p><p>教師　きょうし</p><p>弁護士　べんごし</p><p>看護師　かんごし</p><p>運転手　うんてんて</p><p>研究者　けんきゅうしゃ研修生　けんしゅうせい</p><p>警察官　けいさつかん</p><p>政治家　せいじか</p><p>画家　がか</p><p>作家　さっか</p><p>建築家　けんちくか</p><p>俳優　はいゆう</p><h4 id="ATMの使い方"><a href="#ATMの使い方" class="headerlink" title="ATMの使い方"></a>ATMの使い方</h4><p>お預け入れ　おあずけいれ</p><p>お振り込み　おふりこむ</p><p>お振り替え　おふりかえ</p><p>お引き出し　おひきだし</p><p>通帳記入　つうちょうきにゅう</p><p>残高参照　ざんだかさんしょう</p><p>残高照会　ざんだくしょうかい</p><p>口座　こうざ<code>账户</code></p><h4 id="病気"><a href="#病気" class="headerlink" title="病気"></a>病気</h4><p>頭・お腹・歯が痛い</p><p>熱があります</p><p>咳（せき）・鼻水・血がでます</p><p>吐き気（はきけ）・寒気・目眩（めまい）がします</p><p>下痢（げり）・便秘（べんぴ）・怪我（けが）・火傷（やけど）をします</p><p>食欲（しょくよく）がありません</p><p>肩（かた）が凝（こ）ります</p><p>体が怠（だる）い</p><p>秘密　ひみつ</p><h4 id="体-からだ"><a href="#体-からだ" class="headerlink" title="体　からだ"></a>体　からだ</h4><p>顎　あご</p><p>頸　くび　手首　てくび</p><p>背中　せなか</p><p>腰　こし</p><p>尻　しり</p><p>骨　ほね</p><p>膝　ひざ</p><p>爪　つめ　</p><p>指　ゆび</p><p>肘　ひじ</p><p>腕　うで　<code>臂</code></p><p>胸　むね</p><p>かぜ　風邪</p><p>インフルエンザ　influenza</p><p>盲腸　もうちょう</p><p>ぎっくり腰　ぎっくりごし</p><p>捻挫　ねんざ</p><p>骨折　こっせつ</p><p>二日酔い　ふつかよい　</p><p>動き</p><p>とぶ　飛ぶ　跳ぶ</p><p>走る　奔る　はしる</p><p>泳ぐ　およぐ　潜る　もぐる</p><p>逆立ちする　さかだちする　</p><p>はう　<code>爬</code></p><p>蹴る　ける</p><p>投げる　なげる</p><p>伸ばす　のばす</p><p>曲げる　まげる</p><p>叩く　たたく　</p><p>転ぶ　ころぶ<code>跌倒</code></p><p>振り向く　ふりむく　<code>回头</code></p><p>持ち上げる</p><p>飛び込む</p><h4 id="伝統文化・娯楽"><a href="#伝統文化・娯楽" class="headerlink" title="伝統文化・娯楽"></a>伝統文化・娯楽</h4><p>文楽　ぶんらく</p><p>漫才・落語　まんざい・らくご</p><p>囲碁・将棋　いご・しょうぎ</p><p>パチンコ　<code>弹弓、弹子球</code></p><p>盆踊り　ぼんおどり</p><h4 id="役職名"><a href="#役職名" class="headerlink" title="役職名"></a>役職名</h4><table><thead><tr><th>機構</th><th>役職名</th></tr></thead><tbody><tr><td>くに</td><td>首相（内閣総理大臣）しゅしょう</td></tr><tr><td>都道府県</td><td>知事　ちじ</td></tr><tr><td>市</td><td>市長</td></tr><tr><td>町</td><td>町長　ちょうちょう</td></tr><tr><td>村　むら</td><td>村長　そんちょう</td></tr><tr><td>大学</td><td>学長</td></tr><tr><td>高等・中・小学校</td><td>校長</td></tr><tr><td>幼稚園　ようちえん</td><td>園長</td></tr><tr><td>会社</td><td>会長・社長・重役（じゅうやく）・部長・課長</td></tr><tr><td>銀行</td><td>頭取・支店長</td></tr><tr><td>病院</td><td>院長・看護師長</td></tr></tbody></table><p>衣服</p><p>スーツsuits</p><p>ワンピースone piece<code>连衣裙</code></p><p>上着　うわぎ　下着　したぎ</p><p>ズボン　==法==jupon</p><p>パンツ pants</p><p>スカートskirt</p><p>ブラウスblouse</p><p>シャツshirts</p><p>セーターsweater</p><p>マフラーmuffler</p><p>手袋　てぶくろ<code>手套</code></p><p>レインコートraincoat</p><p>ネクタイ  necktie</p><p>ベルトbelt</p><p>靴下　くつした</p><p>パンティー・ストッキングpanti stocking</p><p>ハイヒールhigh heel</p><p>ブーツboots</p><p>運動靴　うんどうくつ</p><p>ぞうり　下駄</p><p>たび<code>布袜</code></p><p>道路・交通</p><p>歩道　ほどう　横断歩道　おうだんほどう　歩道橋　ほどうきょう</p><p>車道　しゃどう</p><p>高速道路　こうそくどうろ</p><p>通り　とおり<code>马路</code></p><p>交差点　こうさてん　角　かど</p><p>坂　さか</p><p>踏切　ふみきり</p><p>ガソリンスタンド　gasoline stand</p><p>進入禁止　しんにゅうきんし</p><p>一方通行　いっぽつうこう</p><p>駐車禁止　ちゅうしゃきんし　</p><p>右折禁止　うせつきんし</p><p>贈答　ぞうとう</p><p>お年玉　おとしだま</p><p>入学祝　にゅうがくいわい</p><p>卒業祝　そつぎょういわい</p><p>結婚祝　けっこんいわい</p><p>出産祝い　しゅっさんいわい</p><p>お中元　おちゅうげん</p><p>お歳暮　おせんぼ</p><p>お香典　おこうでん</p><p>お見舞い　おみまい</p><p>熨斗袋　のしぶくろ</p><p>人の一生</p><table><thead><tr><th>階段</th><th>こと</th></tr></thead><tbody><tr><td>赤ちゃん</td><td>保育園</td></tr><tr><td>子供</td><td>宿題</td></tr><tr><td>青年</td><td>専門学校・大学・大学院・卒業・就職・結婚</td></tr><tr><td>中年</td><td>離婚・再婚</td></tr><tr><td>老年</td><td>退職</td></tr></tbody></table><h2 id="挨拶-あいさつ"><a href="#挨拶-あいさつ" class="headerlink" title="挨拶　あいさつ"></a>挨拶　あいさつ</h2><p>お出かけですか。</p><p>お上がりください。</p><p>また今度お願いします。</p><p>いっしょにいかがですか。</p><p>おかげさまで。　お陰様で。　<code>托您的福</code></p><p>どうしたの？＝どうしましたか。</p><p>遅い！ちこくするよ。</p><p>どうでしたか。＝How is …?</p><h2 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h2><p>一週間に一回映画をみます。</p><p>スポーツでサッカーが一番おもしろいです。</p><p>本を返さなければなりません。</p><p>カードで払うことができます。</p><p>考（かんが）えでも、わかりません。</p><p>私は課長に会社を辞めると言いました。</p><p>これを回すと、音がおおきくなります。</p><p>26歳のとき、結婚しました。</p><p>ミラーさんがきたら、でかけましょう。　</p><p>そんなに寒くかったです。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;皆さんの日本語-初級上&quot;&gt;&lt;a href=&quot;#皆さんの日本語-初級上&quot; class=&quot;headerlink&quot; title=&quot;皆さんの日本語　初級上&quot;&gt;&lt;/a&gt;皆さんの日本語　初級上&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;覚えにくい、より難しい知識&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;単語&quot;&gt;&lt;a href=&quot;#単語&quot; class=&quot;headerlink&quot; title=&quot;単語&quot;&gt;&lt;/a&gt;単語&lt;/h2&gt;&lt;p&gt;教室　きょうしつ&lt;/p&gt;
&lt;p&gt;授業　じゅぎょう&lt;/p&gt;
&lt;p&gt;橋／箸　はし&lt;/p&gt;
&lt;p&gt;平仮名　ひえあがな&lt;/p&gt;
&lt;p&gt;片仮名　カタカナ&lt;/p&gt;
&lt;p&gt;手伝う　てつだう&lt;/p&gt;
&lt;p&gt;買い物する&lt;/p&gt;
&lt;p&gt;沖縄　おきなわ&lt;/p&gt;</summary>
    
    
    
    <category term="freetime" scheme="http://example.com/categories/freetime/"/>
    
    
    <category term="languages" scheme="http://example.com/tags/languages/"/>
    
  </entry>
  
  <entry>
    <title>王道Python笔记</title>
    <link href="http://example.com/2021/06/23/%E7%8E%8B%E9%81%93Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/06/23/%E7%8E%8B%E9%81%93Python%E7%AC%94%E8%AE%B0/</id>
    <published>2021-06-23T08:50:34.000Z</published>
    <updated>2022-10-09T08:43:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p>现在的服务器，硬件追求性价比，可靠性用软件保证</p><p>系统级进程用数个无密码用户启动，互相独立</p><pre><code class="shell">#给root配置密码sudo passwd rootuseradd -m ... -s /bin/bashuserdel -r</code></pre><h2 id="linux通配"><a href="#linux通配" class="headerlink" title="linux通配"></a>linux通配</h2><table><thead><tr><th></th><th>基本规则</th><th>说明</th></tr></thead><tbody><tr><td>grep</td><td>输出含匹配段的行，首尾规则</td><td>! [] ^ $ * ?</td></tr><tr><td>find/shell/rm等</td><td>输出文件路径，无首尾规则，加-name，加引号</td><td>! [] *(同.*) .</td></tr></tbody></table><span id="more"></span><h1 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h1><p>安装ipython3</p><p>复数 complex(a,b) .real/imag</p><p>命名规范：</p><ul><li>常量全大写，可加下划线</li><li>变量、方法用下划线命名法</li><li>类名用大驼峰命名法</li></ul><p>float类型17位精度</p><p>1 and 3 =3 真则返回后一个</p><p>5 or 0 =5 真则返回前一个</p><p>~x = -x-1</p><p>位操作去重</p><p>并查集、位操作看文献耦合</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>一切变量都是引用</p><p>变量中记录数据的地址，使用id()可以查看</p><p>修改变量值的时候，改变这个地址</p><p>函数传递时，赋值没法改变函数外的值，只有通过可变类型（list|dict|set）</p><p>0-255固定地址（数字表）</p><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>变量在函数内被使用，就近原则</p><p>变量在函数内被赋值，则认为是局部变量</p><p>函数内修改一个全局变量时，必须加global</p><h3 id="三大可变类型"><a href="#三大可变类型" class="headerlink" title="三大可变类型"></a>三大可变类型</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>append、pop(按位删除一次)或del a[i]、remove(按值删除)、count、insert、extend(列表追加)、reverse、sort(reverse=True)归并排序、A.index(按值查下标)</p><p>函数内改变函数外，取下标赋值</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>hash实现</p><p>dict1=dict{}</p><p>key必须是不可变类型，一般放字符串</p><p>dic.get(key)比dic[]更安全</p><p>keys|values|items</p><p>setdefault(key,value) 如key不存在，修改value</p><p>update 覆盖已存在key的value，添加不存在key，实现合并。python 3.9支持加号</p><h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><pre><code class="python">for k in xiaoming:# 等于for k in xiaoming.keys()    print(%s:%s % (k, xiaoming[k]))</code></pre><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>set1=set()</p><p>add、clear、copy</p><p>x.union不改变x，x.update改变x</p><p>a|b  a-b a&amp;b a^b</p><h1 id="day8"><a href="#day8" class="headerlink" title="day8"></a>day8</h1><ul><li>没有return的函数，返回None</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li><p>逆序：str[::-1]</p></li><li><p>list(str) 相当于 split(‘’)，然后用’’.join(list)恢复；字符串切分、读取类似列表，list(str)将其转化成单字符列表</p></li></ol><h1 id="day9"><a href="#day9" class="headerlink" title="day9"></a>day9</h1><ul><li>lis.extend()等价于lis+=… 不改变ID，函数外也会改变</li></ul><h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><ol><li><p>dir(Class)看类的方法和属性</p><p>dir(Object)看对象属性和方法</p></li><li><p>直接打印对象时显示__str__的返回值，__repr__更高级</p></li></ol><h1 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h1><ol><li><p>面向对象的思想：实现任何需求，都创建一个对象，让对象去做</p></li><li><p>file.seek()在非二进制模式下只能向后偏移</p></li></ol><p>二进制模式写入需要转为字节流：</p><ul><li><p>字符串：str.encode(‘utf8’)</p></li><li><p>整型数：struct.pack(‘i’,123)</p></li></ul><ol start="3"><li><p>eval(字符串)-&gt;列表、字典</p><p>eval(‘命令’) 直接执行，danger，尤其在接收网络内容时!!</p></li></ol><h1 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h1><ol><li>python链表</li></ol><pre><code class="python">class Node:    def __init__(self,ele):        self.ele=ele        self.next=None</code></pre><ol start="2"><li><p>堆排序是空间复杂度O（1）的最好排序算法</p></li><li><p>计数排序 时间复杂度最低</p></li><li><p>传递方法时只传方法名字，参数用*args传递</p></li><li><p>用小根堆找第K大元素</p></li></ol><h1 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h1><ul><li>python对整形数移位操作时，该数为无符号数</li></ul><h1 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h1><ul><li><p>ping 使用icmp协议实现的</p></li><li><p>tcp 报文头中有滑动窗口大小</p></li><li><p>tcp头长20，udp头长8  udp效率高，且适用于无线</p></li></ul><h1 id="day18"><a href="#day18" class="headerlink" title="day18"></a>day18</h1><ul><li><p>UDP 的特点： 尽最大努力交付，发送大于接收，接收方直接丢弃，可以多个端口使用同一个描述符和缓冲区，一对多</p></li><li><p>python中TCP在accept成功后会返回套接字和客户端ip，端口元组</p><p>UDP在每次recvfrom时得到发送者的内容和ip，端口元组</p></li><li><p>暂停态(T)用于程序调试</p></li><li><p>nohup 后台运行，jobs查看，fg到前台，bg到后台</p></li><li><p>socket发送和接收整型数</p><pre><code class="python">#发送端socket.send(struct.pack('I',123))#接收端recv_data=socket.recv(4)data=struct.unpack('I',recv_data)[0]</code></pre></li></ul><h1 id="day19"><a href="#day19" class="headerlink" title="day19"></a>day19</h1><ol><li><p>时间片轮转:</p><p>一轮调度周期内把时间分割为若干个时间片，调度器将时间片分配给就绪队列的进程</p></li><li><p>killall/pkill 按名字杀进程</p></li><li><p>crontab -e 设置定时任务</p></li><li><p>子进程创建的一瞬间是父进程的克隆</p></li><li><p>python特色：主线程执行结束前，会等待子线程结束，join用于子线程之间的等待，不写join子线程也会执行到底，因为主线程一直在；C中子线程随着主线程的消亡而消亡，必须要join()</p></li><li><p>join移到了进程里并取代了wait</p></li><li><p>thread类，从run函数进入其他方法</p></li></ol><h1 id="day20"><a href="#day20" class="headerlink" title="day20"></a>day20</h1><ol><li><p>当一个函数有yield 时，他就是一个生成器</p></li><li><p>线程切换比较耗时，操作系统会给每个线程分配cache；每一个协程仅保存压栈寄存器状态，切换时不用进入内核态</p></li><li><p>next(g)，第一次从开头运行到yield，返回yield</p></li></ol><p>后面每一次从yield传参运行到下一个yield传参之前</p><p>正则表达式：</p><table><thead><tr><th>匹配个数</th><th>贪婪</th><th>非贪婪</th></tr></thead><tbody><tr><td>1+</td><td>.+</td><td>.+?</td></tr><tr><td>任意</td><td>.*</td><td>.*?返回空</td></tr><tr><td>0/1</td><td>.{0,1}或.?</td><td>.*?</td></tr><tr><td>1</td><td>.{1}或.</td><td>无</td></tr></tbody></table><p><strong>可以匹配0个的会给$^以及单一匹配让步</strong></p><h1 id="day22"><a href="#day22" class="headerlink" title="day22"></a>day22</h1><ol><li><p>从模块导入全局变量</p><p>import common: 共享</p><p>from common import GVAR：只共享可变类型</p></li><li><p>工厂模式：用工厂的create方法，根据传入的字符串的不同，创建不同的类的对象</p></li></ol><h1 id="day23"><a href="#day23" class="headerlink" title="day23"></a>day23</h1><ol><li><p>assert 为假，抛出断言异常，相当于if+raise</p></li><li><p>dir(类名)看所有类属性和方法，__dict__用于打印类属性方法/对象所有属性和方法</p></li><li><p>__getitem__ 让对象以方括号形式访问</p></li><li><p>mysql 数据类型</p><p><a href="https://www.cnblogs.com/xrq730/p/8446246.html">https://www.cnblogs.com/xrq730/p/8446246.html</a></p><p>char 和 varchar</p><p>对于MyISAM表，推荐CHAR类型；对于InnoDB表，推荐VARCHAR类型</p></li></ol><h1 id="day25"><a href="#day25" class="headerlink" title="day25"></a>day25</h1><pre><code class="sql">UPDATE tablename SET ...=... WHERE ...-- sql注入where id=1 or 1=1--拿到整个数据库-- 解决方法：传参para=[findname]</code></pre><h1 id="day26"><a href="#day26" class="headerlink" title="day26"></a>day26</h1><ol><li><p>主键默认有索引，并且是唯一索引</p></li><li><p>只能在一个表中某一列存在聚集索引，索引值和行数据存储在一起</p></li><li><p>一定要有公网ip才能被任意机器ping通，ping通才能主动发起对被ping通方的连接</p></li><li><p>隔离等级</p><pre><code class="sql">-- 查看select @@tx_isolationselect @@global.tx_isolation-- 修改set session transaction isolation level ...-- read uncommitted-- read committed-- repeatable read(default)-- serializable</code></pre><p><a href="https://elsef.com/2018/11/28/%E7%BB%8F%E5%B8%B8%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84MySQL%E4%B8%AD%E5%AF%B9REPEATABLE-READ/">幻读的详细解释</a></p></li><li><p>配置主从同步mariadb 10和mysql的区别：</p><ol><li>配置文件在/etc/my.cnf</li><li><code>systemctl restart mariadb</code></li></ol></li><li><p>source 和备份恢复都可以导入sql文件，出现<code>utf8mb4_0900_ai_ci</code>编码错误来源于注释掉的行，比较坑爹</p></li><li><p>回调函数：作为参数传入另一个函数的函数，延迟调用，C语言中用函数指针实现</p></li><li><p>主键创建时默认是聚集索引</p></li><li><p>唯一索引可以为null</p></li></ol><h1 id="day27"><a href="#day27" class="headerlink" title="day27"></a>day27</h1><ol><li>闭包：函数里定义的函数，在调用时根据传入参数返回一个新函数</li><li>闭包消耗的资源比对象少，能传递功能和数据</li><li>闭包里的nonloal不释放局部变量，类似于静态局部变量的性质</li><li>使用闭包相当于重写一个函数</li><li>装饰器使用闭包技术，对原来的函数进行了扩展。装饰器需要传参用两层闭包</li><li>离函数更近的装饰器先装饰，后调用</li></ol><h1 id="day32"><a href="#day32" class="headerlink" title="day32"></a>day32</h1><h2 id="数据分析常用方法："><a href="#数据分析常用方法：" class="headerlink" title="数据分析常用方法："></a>数据分析常用方法：</h2><ol><li>对比分析</li><li>多维拆解</li><li>留存分析</li><li>漏斗分析：目的明确</li></ol><h2 id="高级方法："><a href="#高级方法：" class="headerlink" title="高级方法："></a>高级方法：</h2><ol><li>用户画像</li><li>归因查找：末次归因、递减归因、首次归因</li><li>路径挖掘：起点明确</li><li>行为序列：单个用户的操作记录</li></ol><h1 id="day33"><a href="#day33" class="headerlink" title="day33"></a>day33</h1><h2 id="ipython魔法命令："><a href="#ipython魔法命令：" class="headerlink" title="ipython魔法命令："></a>ipython魔法命令：</h2><table><thead><tr><th>魔法命令</th><th>作用</th></tr></thead><tbody><tr><td>%pwd|%cd|%ls</td><td>同shell</td></tr><tr><td>%writefile</td><td>写入文件</td></tr><tr><td>%run  .py/.ipynb</td><td>运行脚本</td></tr><tr><td>%whos|%reset</td><td>查看/清除当前变量</td></tr><tr><td>%timeit</td><td>测试单行代码运行时间</td></tr></tbody></table><h2 id="matplotlib踩坑"><a href="#matplotlib踩坑" class="headerlink" title="matplotlib踩坑"></a>matplotlib踩坑</h2><ol><li><p>动态修改中文</p><pre><code class="python">from matplotlib import font_manager# linuxmyfont = font_manager.FontProperties(fname='/usr/share/fonts/ttf/???.ttf'，size=15) # windowsmy_font = font_manager.FontProperties(fname='C:\Windows\Fonts\???.ttf',size=15) mpl.rcParams['axes.unicode_minus'] = False  # 后面需要显示中文的地方加参数fontsproperties=myfont# 特别的，legend()后面的参数用procproc=myfont</code></pre></li><li><p>全局修改中文</p><pre><code class="python">from matplotlib import pyplot as plt plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False #用来正常显示负号</code></pre></li></ol><h1 id="day37"><a href="#day37" class="headerlink" title="day37"></a>day37</h1><h2 id="chrome-退出ctrl-l-k后地址栏的选中状态"><a href="#chrome-退出ctrl-l-k后地址栏的选中状态" class="headerlink" title="chrome 退出ctrl+l/k后地址栏的选中状态"></a>chrome 退出<code>ctrl+l/k</code>后地址栏的选中状态</h2><p><code>Esc</code>不行，谷歌工程师脑子进水了，只能<code>Tab</code>。</p><h1 id="day46"><a href="#day46" class="headerlink" title="day46"></a>day46</h1><pre><code class="python">from tensorflow import kerasclass WideDeepModel(keras.models.Model):    def __init__(self):    # 继承父类    super().__init__()    self.hidden1_layer = keras.layers.Dense(30, activation='relu')    self.hidden2_layer = keras.layers.Dense(30, activation='relu')    self.output_layer1 = keras.layers.Dense(1)    self.output_layer2 = keras.layers.Dense(1)       def call(self,inputs):    # 定义正向计算，输入张量和输出张量    input_wide=inputs[0]    input_deep=inputs[1]    hidden1=self.hidden1_layer(input_deep)    hidden2=self.hidden2_layer(hidden1)    concat=keras.layers.concatenate([input_wide,hidden2])    output1=self.output_layer1(concat)    output2=self.output_layer2(hidden2)    return [output1,output2]model=WideDeepModel()# 两个输入层的维度model.build(input_shape=[(None,5),(None,6)])model.compile(loss="mean_squared_error",              optimizer = keras.optimizers.SGD(0.001))callbacks = [keras.callbacks.EarlyStopping(    patience=5, min_delta=1e-2)]history = model.fit([x_train_scaled_wide, x_train_scaled_deep],[y_train,y_train],                    validation_data =([x_valid_scaled_wide, x_valid_scaled_deep],[y_valid,y_valid]),                    epochs = 100,                    callbacks = callbacks)</code></pre><h1 id="day49"><a href="#day49" class="headerlink" title="day49"></a>day49</h1><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>每一层的参数计算：上层通道数*卷积核大小*本层通道数 +本层通道数</p><h2 id="modelcheckpoint"><a href="#modelcheckpoint" class="headerlink" title="modelcheckpoint"></a>modelcheckpoint</h2><p>保存之前的最佳模型，再次训练时会在之前的参数上继续训练</p><h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><ol><li>selu比relu收敛更快</li><li>卷积和池化都能减少过拟合</li></ol><h1 id="day50"><a href="#day50" class="headerlink" title="day50"></a>day50</h1><h2 id="plot-model"><a href="#plot-model" class="headerlink" title="plot_model"></a>plot_model</h2><pre><code class="python">from tensorflow.keras.utils import plot_modelplot_model(single_rnn_model)</code></pre><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>根据上下文预测</p><p>保存权重而不是模型，可以改变传入批次的大小</p><h1 id="day55"><a href="#day55" class="headerlink" title="day55"></a>day55</h1><p>白化：</p><ol><li>PCA白化 均值为0,方差为1</li><li>ZCA白化 均值为0,方差相同</li></ol><p>批归一化：对各维度分别 均值为0,方差为1，再添加缩放和偏移保留部分数据分布特征</p><h1 id="day56"><a href="#day56" class="headerlink" title="day56"></a>day56</h1><p>route -n 看网关</p><p>lsof -i:端口号 </p><h1 id="day58"><a href="#day58" class="headerlink" title="day58"></a>day58</h1><h2 id="hadoop-x2F-YARN-架构"><a href="#hadoop-x2F-YARN-架构" class="headerlink" title="hadoop/YARN 架构"></a>hadoop/YARN 架构</h2><p>mapreduce的调度计算分给resourceManager，本身只负责数据统计计算</p><ol><li><p>client 按128M/块分割好的数据存储到datanode(默认3份)，namenode放元数据（类似于Linux目录结构体信息）</p></li><li><p>client 向resourceManager提交jobs</p></li><li><p>主机的resourceManager和nodeManage协商，jobs分解为tasks，初始化container，分发管家applicationMaster给container，管家申请资源，注册进程</p></li><li><p>applicationMaster向nodeManager申请启动，把task给container</p></li><li><p>task执行完毕，向管家报告，管家请求kill</p></li><li><p>namenode定期汇报datanode；nodemanager定期汇报container</p></li></ol><h2 id="hadoop启动"><a href="#hadoop启动" class="headerlink" title="hadoop启动"></a>hadoop启动</h2><pre><code class="shell">./start-all.sh</code></pre><h2 id="hive启动"><a href="#hive启动" class="headerlink" title="hive启动"></a>hive启动</h2><pre><code class="shell">service docker startdocker start mysqlhive --service matestore &amp;hive</code></pre><h1 id="day68"><a href="#day68" class="headerlink" title="day68"></a>day68</h1><p>grpc：远程过程调用，客户端直接调用服务端的函数</p><h1 id="day72"><a href="#day72" class="headerlink" title="day72"></a>day72</h1><ol><li><p>在django model 层设置外键，mysql 的外键db_constraint设为false以提高效率</p></li><li><p>先用一对一，扩展为一对多很方便</p></li></ol><h1 id="bounces-in-wangdao"><a href="#bounces-in-wangdao" class="headerlink" title="bounces in wangdao"></a>bounces in wangdao</h1><ul><li><p><input checked="" disabled="" type="checkbox"> 红黑树完整代码</p></li><li><p><input disabled="" type="checkbox"> 图神经网络</p></li><li><p><input disabled="" type="checkbox"> 网络科学导论</p></li><li><p><input disabled="" type="checkbox"> 统计学习方法</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;day2&quot;&gt;&lt;a href=&quot;#day2&quot; class=&quot;headerlink&quot; title=&quot;day2&quot;&gt;&lt;/a&gt;day2&lt;/h1&gt;&lt;p&gt;现在的服务器，硬件追求性价比，可靠性用软件保证&lt;/p&gt;
&lt;p&gt;系统级进程用数个无密码用户启动，互相独立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;#给root配置密码
sudo passwd root

useradd -m ... -s /bin/bash

userdel -r
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;linux通配&quot;&gt;&lt;a href=&quot;#linux通配&quot; class=&quot;headerlink&quot; title=&quot;linux通配&quot;&gt;&lt;/a&gt;linux通配&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;基本规则&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;输出含匹配段的行，首尾规则&lt;/td&gt;
&lt;td&gt;! [] ^ $ * ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find/shell/rm等&lt;/td&gt;
&lt;td&gt;输出文件路径，无首尾规则，加-name，加引号&lt;/td&gt;
&lt;td&gt;! [] *(同.*) .&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>hexo workflow</title>
    <link href="http://example.com/2021/06/19/hexo-workflow/"/>
    <id>http://example.com/2021/06/19/hexo-workflow/</id>
    <published>2021-06-19T12:29:51.000Z</published>
    <updated>2022-10-09T08:44:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo写博客基本流程"><a href="#hexo写博客基本流程" class="headerlink" title="hexo写博客基本流程"></a>hexo写博客基本流程</h1><pre><code class="bash">cd ~/bloghexo new "article name"# 打开桌面post文件夹的快捷方式# 用typora编辑新建好的md文件# 添加tags# 选择categories: tech-article or freetime# 原来写好的只能新建后复制内容hexo clean &amp;&amp; hexo g &amp;&amp; hexo d# 可以alias成一条命令 fabu# 删除直接删文件</code></pre><h1 id="发布前的处理"><a href="#发布前的处理" class="headerlink" title="发布前的处理"></a>发布前的处理</h1><p>鉴于hexo各个渲染器的不完备，即使选择相对较好的pandoc，也要在发布前预处理。</p><ol><li><p>图片去除相对路径和中括号里的图注，只留下小括号里文件名。<del>这样会在typora本地看不到图片。</del></p><blockquote><p>用obsidian完美解决</p></blockquote></li><li><p>多行公式分块，行内公式不能有空格。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo写博客基本流程&quot;&gt;&lt;a href=&quot;#hexo写博客基本流程&quot; class=&quot;headerlink&quot; title=&quot;hexo写博客基本流程&quot;&gt;&lt;/a&gt;hexo写博客基本流程&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;cd ~/blog
hex</summary>
      
    
    
    
    <category term="tech-article" scheme="http://example.com/categories/tech-article/"/>
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
</feed>
